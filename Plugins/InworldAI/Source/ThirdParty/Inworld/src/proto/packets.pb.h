// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packets.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_packets_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_packets_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include "options.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_packets_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_packets_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_packets_2eproto;
namespace ai {
namespace inworld {
namespace packets {
class ActionEvent;
class ActionEventDefaultTypeInternal;
extern ActionEventDefaultTypeInternal _ActionEvent_default_instance_;
class Actor;
class ActorDefaultTypeInternal;
extern ActorDefaultTypeInternal _Actor_default_instance_;
class AdditionalPhonemeInfo;
class AdditionalPhonemeInfoDefaultTypeInternal;
extern AdditionalPhonemeInfoDefaultTypeInternal _AdditionalPhonemeInfo_default_instance_;
class ApplyResponse;
class ApplyResponseDefaultTypeInternal;
extern ApplyResponseDefaultTypeInternal _ApplyResponse_default_instance_;
class AudioChunk;
class AudioChunkDefaultTypeInternal;
extern AudioChunkDefaultTypeInternal _AudioChunk_default_instance_;
class CancelResponses;
class CancelResponsesDefaultTypeInternal;
extern CancelResponsesDefaultTypeInternal _CancelResponses_default_instance_;
class CancelResponsesEvent;
class CancelResponsesEventDefaultTypeInternal;
extern CancelResponsesEventDefaultTypeInternal _CancelResponsesEvent_default_instance_;
class ControlEvent;
class ControlEventDefaultTypeInternal;
extern ControlEventDefaultTypeInternal _ControlEvent_default_instance_;
class CustomEvent;
class CustomEventDefaultTypeInternal;
extern CustomEventDefaultTypeInternal _CustomEvent_default_instance_;
class CustomEvent_Parameter;
class CustomEvent_ParameterDefaultTypeInternal;
extern CustomEvent_ParameterDefaultTypeInternal _CustomEvent_Parameter_default_instance_;
class DataChunk;
class DataChunkDefaultTypeInternal;
extern DataChunkDefaultTypeInternal _DataChunk_default_instance_;
class DebugInfoEvent;
class DebugInfoEventDefaultTypeInternal;
extern DebugInfoEventDefaultTypeInternal _DebugInfoEvent_default_instance_;
class EmotionEvent;
class EmotionEventDefaultTypeInternal;
extern EmotionEventDefaultTypeInternal _EmotionEvent_default_instance_;
class InworldPacket;
class InworldPacketDefaultTypeInternal;
extern InworldPacketDefaultTypeInternal _InworldPacket_default_instance_;
class LoadScene;
class LoadSceneDefaultTypeInternal;
extern LoadSceneDefaultTypeInternal _LoadScene_default_instance_;
class LoadSceneOutputEvent;
class LoadSceneOutputEventDefaultTypeInternal;
extern LoadSceneOutputEventDefaultTypeInternal _LoadSceneOutputEvent_default_instance_;
class LoadSceneOutputEvent_Agent;
class LoadSceneOutputEvent_AgentDefaultTypeInternal;
extern LoadSceneOutputEvent_AgentDefaultTypeInternal _LoadSceneOutputEvent_Agent_default_instance_;
class ModifyExactResponse;
class ModifyExactResponseDefaultTypeInternal;
extern ModifyExactResponseDefaultTypeInternal _ModifyExactResponse_default_instance_;
class MutationEvent;
class MutationEventDefaultTypeInternal;
extern MutationEventDefaultTypeInternal _MutationEvent_default_instance_;
class NarratedAction;
class NarratedActionDefaultTypeInternal;
extern NarratedActionDefaultTypeInternal _NarratedAction_default_instance_;
class PacketId;
class PacketIdDefaultTypeInternal;
extern PacketIdDefaultTypeInternal _PacketId_default_instance_;
class RegenerateResponse;
class RegenerateResponseDefaultTypeInternal;
extern RegenerateResponseDefaultTypeInternal _RegenerateResponse_default_instance_;
class RelationInfo;
class RelationInfoDefaultTypeInternal;
extern RelationInfoDefaultTypeInternal _RelationInfo_default_instance_;
class RelationInfo_RelationAttributes;
class RelationInfo_RelationAttributesDefaultTypeInternal;
extern RelationInfo_RelationAttributesDefaultTypeInternal _RelationInfo_RelationAttributes_default_instance_;
class Routing;
class RoutingDefaultTypeInternal;
extern RoutingDefaultTypeInternal _Routing_default_instance_;
class TextEvent;
class TextEventDefaultTypeInternal;
extern TextEventDefaultTypeInternal _TextEvent_default_instance_;
class TextEvent_ModelInfo;
class TextEvent_ModelInfoDefaultTypeInternal;
extern TextEvent_ModelInfoDefaultTypeInternal _TextEvent_ModelInfo_default_instance_;
}  // namespace packets
}  // namespace inworld
}  // namespace ai
PROTOBUF_NAMESPACE_OPEN
template<> ::ai::inworld::packets::ActionEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::ActionEvent>(Arena*);
template<> ::ai::inworld::packets::Actor* Arena::CreateMaybeMessage<::ai::inworld::packets::Actor>(Arena*);
template<> ::ai::inworld::packets::AdditionalPhonemeInfo* Arena::CreateMaybeMessage<::ai::inworld::packets::AdditionalPhonemeInfo>(Arena*);
template<> ::ai::inworld::packets::ApplyResponse* Arena::CreateMaybeMessage<::ai::inworld::packets::ApplyResponse>(Arena*);
template<> ::ai::inworld::packets::AudioChunk* Arena::CreateMaybeMessage<::ai::inworld::packets::AudioChunk>(Arena*);
template<> ::ai::inworld::packets::CancelResponses* Arena::CreateMaybeMessage<::ai::inworld::packets::CancelResponses>(Arena*);
template<> ::ai::inworld::packets::CancelResponsesEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::CancelResponsesEvent>(Arena*);
template<> ::ai::inworld::packets::ControlEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::ControlEvent>(Arena*);
template<> ::ai::inworld::packets::CustomEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::CustomEvent>(Arena*);
template<> ::ai::inworld::packets::CustomEvent_Parameter* Arena::CreateMaybeMessage<::ai::inworld::packets::CustomEvent_Parameter>(Arena*);
template<> ::ai::inworld::packets::DataChunk* Arena::CreateMaybeMessage<::ai::inworld::packets::DataChunk>(Arena*);
template<> ::ai::inworld::packets::DebugInfoEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::DebugInfoEvent>(Arena*);
template<> ::ai::inworld::packets::EmotionEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::EmotionEvent>(Arena*);
template<> ::ai::inworld::packets::InworldPacket* Arena::CreateMaybeMessage<::ai::inworld::packets::InworldPacket>(Arena*);
template<> ::ai::inworld::packets::LoadScene* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadScene>(Arena*);
template<> ::ai::inworld::packets::LoadSceneOutputEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadSceneOutputEvent>(Arena*);
template<> ::ai::inworld::packets::LoadSceneOutputEvent_Agent* Arena::CreateMaybeMessage<::ai::inworld::packets::LoadSceneOutputEvent_Agent>(Arena*);
template<> ::ai::inworld::packets::ModifyExactResponse* Arena::CreateMaybeMessage<::ai::inworld::packets::ModifyExactResponse>(Arena*);
template<> ::ai::inworld::packets::MutationEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::MutationEvent>(Arena*);
template<> ::ai::inworld::packets::NarratedAction* Arena::CreateMaybeMessage<::ai::inworld::packets::NarratedAction>(Arena*);
template<> ::ai::inworld::packets::PacketId* Arena::CreateMaybeMessage<::ai::inworld::packets::PacketId>(Arena*);
template<> ::ai::inworld::packets::RegenerateResponse* Arena::CreateMaybeMessage<::ai::inworld::packets::RegenerateResponse>(Arena*);
template<> ::ai::inworld::packets::RelationInfo* Arena::CreateMaybeMessage<::ai::inworld::packets::RelationInfo>(Arena*);
template<> ::ai::inworld::packets::RelationInfo_RelationAttributes* Arena::CreateMaybeMessage<::ai::inworld::packets::RelationInfo_RelationAttributes>(Arena*);
template<> ::ai::inworld::packets::Routing* Arena::CreateMaybeMessage<::ai::inworld::packets::Routing>(Arena*);
template<> ::ai::inworld::packets::TextEvent* Arena::CreateMaybeMessage<::ai::inworld::packets::TextEvent>(Arena*);
template<> ::ai::inworld::packets::TextEvent_ModelInfo* Arena::CreateMaybeMessage<::ai::inworld::packets::TextEvent_ModelInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ai {
namespace inworld {
namespace packets {

enum Actor_Type : int {
  Actor_Type_UNKNOWN = 0,
  Actor_Type_PLAYER = 1,
  Actor_Type_AGENT = 2,
  Actor_Type_Actor_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Actor_Type_Actor_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Actor_Type_IsValid(int value);
constexpr Actor_Type Actor_Type_Type_MIN = Actor_Type_UNKNOWN;
constexpr Actor_Type Actor_Type_Type_MAX = Actor_Type_AGENT;
constexpr int Actor_Type_Type_ARRAYSIZE = Actor_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Actor_Type_descriptor();
template<typename T>
inline const std::string& Actor_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Actor_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Actor_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Actor_Type_descriptor(), enum_t_value);
}
inline bool Actor_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Actor_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Actor_Type>(
    Actor_Type_descriptor(), name, value);
}
enum TextEvent_SourceType : int {
  TextEvent_SourceType_UNKNOWN = 0,
  TextEvent_SourceType_SPEECH_TO_TEXT = 1,
  TextEvent_SourceType_TYPED_IN = 2,
  TextEvent_SourceType_GENERATED = 3,
  TextEvent_SourceType_FILLER = 4,
  TextEvent_SourceType_TextEvent_SourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TextEvent_SourceType_TextEvent_SourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TextEvent_SourceType_IsValid(int value);
constexpr TextEvent_SourceType TextEvent_SourceType_SourceType_MIN = TextEvent_SourceType_UNKNOWN;
constexpr TextEvent_SourceType TextEvent_SourceType_SourceType_MAX = TextEvent_SourceType_FILLER;
constexpr int TextEvent_SourceType_SourceType_ARRAYSIZE = TextEvent_SourceType_SourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TextEvent_SourceType_descriptor();
template<typename T>
inline const std::string& TextEvent_SourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextEvent_SourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextEvent_SourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TextEvent_SourceType_descriptor(), enum_t_value);
}
inline bool TextEvent_SourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextEvent_SourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TextEvent_SourceType>(
    TextEvent_SourceType_descriptor(), name, value);
}
enum ControlEvent_Action : int {
  ControlEvent_Action_UNKNOWN = 0,
  ControlEvent_Action_AUDIO_SESSION_START = 1,
  ControlEvent_Action_AUDIO_SESSION_END = 2,
  ControlEvent_Action_INTERACTION_END = 3,
  ControlEvent_Action_TTS_PLAYBACK_START = 4,
  ControlEvent_Action_TTS_PLAYBACK_END = 5,
  ControlEvent_Action_TTS_PLAYBACK_MUTE = 6,
  ControlEvent_Action_TTS_PLAYBACK_UNMUTE = 7,
  ControlEvent_Action_WARNING = 8,
  ControlEvent_Action_SESSION_END = 9,
  ControlEvent_Action_ControlEvent_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ControlEvent_Action_ControlEvent_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ControlEvent_Action_IsValid(int value);
constexpr ControlEvent_Action ControlEvent_Action_Action_MIN = ControlEvent_Action_UNKNOWN;
constexpr ControlEvent_Action ControlEvent_Action_Action_MAX = ControlEvent_Action_SESSION_END;
constexpr int ControlEvent_Action_Action_ARRAYSIZE = ControlEvent_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlEvent_Action_descriptor();
template<typename T>
inline const std::string& ControlEvent_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControlEvent_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControlEvent_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControlEvent_Action_descriptor(), enum_t_value);
}
inline bool ControlEvent_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ControlEvent_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlEvent_Action>(
    ControlEvent_Action_descriptor(), name, value);
}
enum EmotionEvent_SpaffCode : int {
  EmotionEvent_SpaffCode_NEUTRAL = 0,
  EmotionEvent_SpaffCode_DISGUST = 1,
  EmotionEvent_SpaffCode_CONTEMPT = 2,
  EmotionEvent_SpaffCode_BELLIGERENCE = 3,
  EmotionEvent_SpaffCode_DOMINEERING = 4,
  EmotionEvent_SpaffCode_CRITICISM = 5,
  EmotionEvent_SpaffCode_ANGER = 6,
  EmotionEvent_SpaffCode_TENSION = 7,
  EmotionEvent_SpaffCode_TENSE_HUMOR = 8,
  EmotionEvent_SpaffCode_DEFENSIVENESS = 9,
  EmotionEvent_SpaffCode_WHINING = 10,
  EmotionEvent_SpaffCode_SADNESS = 11,
  EmotionEvent_SpaffCode_STONEWALLING = 12,
  EmotionEvent_SpaffCode_INTEREST = 13,
  EmotionEvent_SpaffCode_VALIDATION = 14,
  EmotionEvent_SpaffCode_AFFECTION = 15,
  EmotionEvent_SpaffCode_HUMOR = 16,
  EmotionEvent_SpaffCode_SURPRISE = 17,
  EmotionEvent_SpaffCode_JOY = 18,
  EmotionEvent_SpaffCode_EmotionEvent_SpaffCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EmotionEvent_SpaffCode_EmotionEvent_SpaffCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EmotionEvent_SpaffCode_IsValid(int value);
constexpr EmotionEvent_SpaffCode EmotionEvent_SpaffCode_SpaffCode_MIN = EmotionEvent_SpaffCode_NEUTRAL;
constexpr EmotionEvent_SpaffCode EmotionEvent_SpaffCode_SpaffCode_MAX = EmotionEvent_SpaffCode_JOY;
constexpr int EmotionEvent_SpaffCode_SpaffCode_ARRAYSIZE = EmotionEvent_SpaffCode_SpaffCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EmotionEvent_SpaffCode_descriptor();
template<typename T>
inline const std::string& EmotionEvent_SpaffCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EmotionEvent_SpaffCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EmotionEvent_SpaffCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EmotionEvent_SpaffCode_descriptor(), enum_t_value);
}
inline bool EmotionEvent_SpaffCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EmotionEvent_SpaffCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EmotionEvent_SpaffCode>(
    EmotionEvent_SpaffCode_descriptor(), name, value);
}
enum EmotionEvent_Strength : int {
  EmotionEvent_Strength_UNSPECIFIED = 0,
  EmotionEvent_Strength_WEAK = 1,
  EmotionEvent_Strength_STRONG = 2,
  EmotionEvent_Strength_NORMAL = 3,
  EmotionEvent_Strength_EmotionEvent_Strength_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EmotionEvent_Strength_EmotionEvent_Strength_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EmotionEvent_Strength_IsValid(int value);
constexpr EmotionEvent_Strength EmotionEvent_Strength_Strength_MIN = EmotionEvent_Strength_UNSPECIFIED;
constexpr EmotionEvent_Strength EmotionEvent_Strength_Strength_MAX = EmotionEvent_Strength_NORMAL;
constexpr int EmotionEvent_Strength_Strength_ARRAYSIZE = EmotionEvent_Strength_Strength_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EmotionEvent_Strength_descriptor();
template<typename T>
inline const std::string& EmotionEvent_Strength_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EmotionEvent_Strength>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EmotionEvent_Strength_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EmotionEvent_Strength_descriptor(), enum_t_value);
}
inline bool EmotionEvent_Strength_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EmotionEvent_Strength* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EmotionEvent_Strength>(
    EmotionEvent_Strength_descriptor(), name, value);
}
enum DataChunk_DataType : int {
  DataChunk_DataType_UNSPECIFIED = 0,
  DataChunk_DataType_AUDIO = 1,
  DataChunk_DataType_SILENCE = 3,
  DataChunk_DataType_STATE = 4,
  DataChunk_DataType_DataChunk_DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataChunk_DataType_DataChunk_DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataChunk_DataType_IsValid(int value);
constexpr DataChunk_DataType DataChunk_DataType_DataType_MIN = DataChunk_DataType_UNSPECIFIED;
constexpr DataChunk_DataType DataChunk_DataType_DataType_MAX = DataChunk_DataType_STATE;
constexpr int DataChunk_DataType_DataType_ARRAYSIZE = DataChunk_DataType_DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataChunk_DataType_descriptor();
template<typename T>
inline const std::string& DataChunk_DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataChunk_DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataChunk_DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataChunk_DataType_descriptor(), enum_t_value);
}
inline bool DataChunk_DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataChunk_DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataChunk_DataType>(
    DataChunk_DataType_descriptor(), name, value);
}
enum DataChunk_AudioFormat : int {
  DataChunk_AudioFormat_UNSPECIFIED_AUDIO_FORMAT = 0,
  DataChunk_AudioFormat_AUDIO_MP3 = 1,
  DataChunk_AudioFormat_AUDIO_PCM_16000 = 2,
  DataChunk_AudioFormat_AUDIO_PCM_22050 = 3,
  DataChunk_AudioFormat_DataChunk_AudioFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataChunk_AudioFormat_DataChunk_AudioFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataChunk_AudioFormat_IsValid(int value);
constexpr DataChunk_AudioFormat DataChunk_AudioFormat_AudioFormat_MIN = DataChunk_AudioFormat_UNSPECIFIED_AUDIO_FORMAT;
constexpr DataChunk_AudioFormat DataChunk_AudioFormat_AudioFormat_MAX = DataChunk_AudioFormat_AUDIO_PCM_22050;
constexpr int DataChunk_AudioFormat_AudioFormat_ARRAYSIZE = DataChunk_AudioFormat_AudioFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataChunk_AudioFormat_descriptor();
template<typename T>
inline const std::string& DataChunk_AudioFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataChunk_AudioFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataChunk_AudioFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataChunk_AudioFormat_descriptor(), enum_t_value);
}
inline bool DataChunk_AudioFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataChunk_AudioFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataChunk_AudioFormat>(
    DataChunk_AudioFormat_descriptor(), name, value);
}
enum Playback : int {
  UNSPECIFIED = 0,
  INTERACTION = 1,
  INTERACTION_END = 2,
  UTTERANCE = 3,
  Playback_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Playback_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Playback_IsValid(int value);
constexpr Playback Playback_MIN = UNSPECIFIED;
constexpr Playback Playback_MAX = UTTERANCE;
constexpr int Playback_ARRAYSIZE = Playback_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Playback_descriptor();
template<typename T>
inline const std::string& Playback_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Playback>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Playback_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Playback_descriptor(), enum_t_value);
}
inline bool Playback_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Playback* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Playback>(
    Playback_descriptor(), name, value);
}
// ===================================================================

class Actor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Actor) */ {
 public:
  inline Actor() : Actor(nullptr) {}
  virtual ~Actor();

  Actor(const Actor& from);
  Actor(Actor&& from) noexcept
    : Actor() {
    *this = ::std::move(from);
  }

  inline Actor& operator=(const Actor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Actor& operator=(Actor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Actor& default_instance();

  static inline const Actor* internal_default_instance() {
    return reinterpret_cast<const Actor*>(
               &_Actor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Actor& a, Actor& b) {
    a.Swap(&b);
  }
  inline void Swap(Actor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Actor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Actor* New() const final {
    return CreateMaybeMessage<Actor>(nullptr);
  }

  Actor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Actor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Actor& from);
  void MergeFrom(const Actor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Actor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Actor";
  }
  protected:
  explicit Actor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Actor_Type Type;
  static constexpr Type UNKNOWN =
    Actor_Type_UNKNOWN;
  static constexpr Type PLAYER =
    Actor_Type_PLAYER;
  static constexpr Type AGENT =
    Actor_Type_AGENT;
  static inline bool Type_IsValid(int value) {
    return Actor_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Actor_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Actor_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Actor_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Actor_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Actor_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Actor_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ai.inworld.packets.Actor.Type type = 1;
  void clear_type();
  ::ai::inworld::packets::Actor_Type type() const;
  void set_type(::ai::inworld::packets::Actor_Type value);
  private:
  ::ai::inworld::packets::Actor_Type _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::Actor_Type value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Actor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class Routing PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.Routing) */ {
 public:
  inline Routing() : Routing(nullptr) {}
  virtual ~Routing();

  Routing(const Routing& from);
  Routing(Routing&& from) noexcept
    : Routing() {
    *this = ::std::move(from);
  }

  inline Routing& operator=(const Routing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Routing& operator=(Routing&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Routing& default_instance();

  static inline const Routing* internal_default_instance() {
    return reinterpret_cast<const Routing*>(
               &_Routing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Routing& a, Routing& b) {
    a.Swap(&b);
  }
  inline void Swap(Routing* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Routing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Routing* New() const final {
    return CreateMaybeMessage<Routing>(nullptr);
  }

  Routing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Routing>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Routing& from);
  void MergeFrom(const Routing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Routing* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.Routing";
  }
  protected:
  explicit Routing(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // .ai.inworld.packets.Actor source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::ai::inworld::packets::Actor& source() const;
  ::ai::inworld::packets::Actor* release_source();
  ::ai::inworld::packets::Actor* mutable_source();
  void set_allocated_source(::ai::inworld::packets::Actor* source);
  private:
  const ::ai::inworld::packets::Actor& _internal_source() const;
  ::ai::inworld::packets::Actor* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::ai::inworld::packets::Actor* source);
  ::ai::inworld::packets::Actor* unsafe_arena_release_source();

  // .ai.inworld.packets.Actor target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::ai::inworld::packets::Actor& target() const;
  ::ai::inworld::packets::Actor* release_target();
  ::ai::inworld::packets::Actor* mutable_target();
  void set_allocated_target(::ai::inworld::packets::Actor* target);
  private:
  const ::ai::inworld::packets::Actor& _internal_target() const;
  ::ai::inworld::packets::Actor* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::ai::inworld::packets::Actor* target);
  ::ai::inworld::packets::Actor* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.Routing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ai::inworld::packets::Actor* source_;
  ::ai::inworld::packets::Actor* target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class PacketId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.PacketId) */ {
 public:
  inline PacketId() : PacketId(nullptr) {}
  virtual ~PacketId();

  PacketId(const PacketId& from);
  PacketId(PacketId&& from) noexcept
    : PacketId() {
    *this = ::std::move(from);
  }

  inline PacketId& operator=(const PacketId& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketId& operator=(PacketId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PacketId& default_instance();

  static inline const PacketId* internal_default_instance() {
    return reinterpret_cast<const PacketId*>(
               &_PacketId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PacketId& a, PacketId& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PacketId* New() const final {
    return CreateMaybeMessage<PacketId>(nullptr);
  }

  PacketId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PacketId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PacketId& from);
  void MergeFrom(const PacketId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.PacketId";
  }
  protected:
  explicit PacketId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketIdFieldNumber = 1,
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 3,
    kCorrelationIdFieldNumber = 4,
  };
  // string packet_id = 1;
  void clear_packet_id();
  const std::string& packet_id() const;
  void set_packet_id(const std::string& value);
  void set_packet_id(std::string&& value);
  void set_packet_id(const char* value);
  void set_packet_id(const char* value, size_t size);
  std::string* mutable_packet_id();
  std::string* release_packet_id();
  void set_allocated_packet_id(std::string* packet_id);
  private:
  const std::string& _internal_packet_id() const;
  void _internal_set_packet_id(const std::string& value);
  std::string* _internal_mutable_packet_id();
  public:

  // string utterance_id = 2;
  void clear_utterance_id();
  const std::string& utterance_id() const;
  void set_utterance_id(const std::string& value);
  void set_utterance_id(std::string&& value);
  void set_utterance_id(const char* value);
  void set_utterance_id(const char* value, size_t size);
  std::string* mutable_utterance_id();
  std::string* release_utterance_id();
  void set_allocated_utterance_id(std::string* utterance_id);
  private:
  const std::string& _internal_utterance_id() const;
  void _internal_set_utterance_id(const std::string& value);
  std::string* _internal_mutable_utterance_id();
  public:

  // string interaction_id = 3;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // string correlation_id = 4;
  void clear_correlation_id();
  const std::string& correlation_id() const;
  void set_correlation_id(const std::string& value);
  void set_correlation_id(std::string&& value);
  void set_correlation_id(const char* value);
  void set_correlation_id(const char* value, size_t size);
  std::string* mutable_correlation_id();
  std::string* release_correlation_id();
  void set_allocated_correlation_id(std::string* correlation_id);
  private:
  const std::string& _internal_correlation_id() const;
  void _internal_set_correlation_id(const std::string& value);
  std::string* _internal_mutable_correlation_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.PacketId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr packet_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utterance_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr correlation_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class InworldPacket PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.InworldPacket) */ {
 public:
  inline InworldPacket() : InworldPacket(nullptr) {}
  virtual ~InworldPacket();

  InworldPacket(const InworldPacket& from);
  InworldPacket(InworldPacket&& from) noexcept
    : InworldPacket() {
    *this = ::std::move(from);
  }

  inline InworldPacket& operator=(const InworldPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline InworldPacket& operator=(InworldPacket&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InworldPacket& default_instance();

  enum PacketCase {
    kText = 2,
    kControl = 3,
    kAudioChunk = 4,
    kCustom = 8,
    kCancelResponses = 10,
    kEmotion = 11,
    kDataChunk = 12,
    kAction = 13,
    kMutation = 15,
    kLoadSceneOutput = 16,
    kDebugInfo = 18,
    PACKET_NOT_SET = 0,
  };

  static inline const InworldPacket* internal_default_instance() {
    return reinterpret_cast<const InworldPacket*>(
               &_InworldPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InworldPacket& a, InworldPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(InworldPacket* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InworldPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InworldPacket* New() const final {
    return CreateMaybeMessage<InworldPacket>(nullptr);
  }

  InworldPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InworldPacket>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InworldPacket& from);
  void MergeFrom(const InworldPacket& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InworldPacket* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.InworldPacket";
  }
  protected:
  explicit InworldPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kRoutingFieldNumber = 6,
    kPacketIdFieldNumber = 9,
    kTextFieldNumber = 2,
    kControlFieldNumber = 3,
    kAudioChunkFieldNumber = 4,
    kCustomFieldNumber = 8,
    kCancelResponsesFieldNumber = 10,
    kEmotionFieldNumber = 11,
    kDataChunkFieldNumber = 12,
    kActionFieldNumber = 13,
    kMutationFieldNumber = 15,
    kLoadSceneOutputFieldNumber = 16,
    kDebugInfoFieldNumber = 18,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .ai.inworld.packets.Routing routing = 6;
  bool has_routing() const;
  private:
  bool _internal_has_routing() const;
  public:
  void clear_routing();
  const ::ai::inworld::packets::Routing& routing() const;
  ::ai::inworld::packets::Routing* release_routing();
  ::ai::inworld::packets::Routing* mutable_routing();
  void set_allocated_routing(::ai::inworld::packets::Routing* routing);
  private:
  const ::ai::inworld::packets::Routing& _internal_routing() const;
  ::ai::inworld::packets::Routing* _internal_mutable_routing();
  public:
  void unsafe_arena_set_allocated_routing(
      ::ai::inworld::packets::Routing* routing);
  ::ai::inworld::packets::Routing* unsafe_arena_release_routing();

  // .ai.inworld.packets.PacketId packet_id = 9;
  bool has_packet_id() const;
  private:
  bool _internal_has_packet_id() const;
  public:
  void clear_packet_id();
  const ::ai::inworld::packets::PacketId& packet_id() const;
  ::ai::inworld::packets::PacketId* release_packet_id();
  ::ai::inworld::packets::PacketId* mutable_packet_id();
  void set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id);
  private:
  const ::ai::inworld::packets::PacketId& _internal_packet_id() const;
  ::ai::inworld::packets::PacketId* _internal_mutable_packet_id();
  public:
  void unsafe_arena_set_allocated_packet_id(
      ::ai::inworld::packets::PacketId* packet_id);
  ::ai::inworld::packets::PacketId* unsafe_arena_release_packet_id();

  // .ai.inworld.packets.TextEvent text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::ai::inworld::packets::TextEvent& text() const;
  ::ai::inworld::packets::TextEvent* release_text();
  ::ai::inworld::packets::TextEvent* mutable_text();
  void set_allocated_text(::ai::inworld::packets::TextEvent* text);
  private:
  const ::ai::inworld::packets::TextEvent& _internal_text() const;
  ::ai::inworld::packets::TextEvent* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::ai::inworld::packets::TextEvent* text);
  ::ai::inworld::packets::TextEvent* unsafe_arena_release_text();

  // .ai.inworld.packets.ControlEvent control = 3;
  bool has_control() const;
  private:
  bool _internal_has_control() const;
  public:
  void clear_control();
  const ::ai::inworld::packets::ControlEvent& control() const;
  ::ai::inworld::packets::ControlEvent* release_control();
  ::ai::inworld::packets::ControlEvent* mutable_control();
  void set_allocated_control(::ai::inworld::packets::ControlEvent* control);
  private:
  const ::ai::inworld::packets::ControlEvent& _internal_control() const;
  ::ai::inworld::packets::ControlEvent* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::ai::inworld::packets::ControlEvent* control);
  ::ai::inworld::packets::ControlEvent* unsafe_arena_release_control();

  // .ai.inworld.packets.AudioChunk audio_chunk = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_audio_chunk() const;
  private:
  bool _internal_has_audio_chunk() const;
  public:
  PROTOBUF_DEPRECATED void clear_audio_chunk();
  PROTOBUF_DEPRECATED const ::ai::inworld::packets::AudioChunk& audio_chunk() const;
  PROTOBUF_DEPRECATED ::ai::inworld::packets::AudioChunk* release_audio_chunk();
  PROTOBUF_DEPRECATED ::ai::inworld::packets::AudioChunk* mutable_audio_chunk();
  PROTOBUF_DEPRECATED void set_allocated_audio_chunk(::ai::inworld::packets::AudioChunk* audio_chunk);
  private:
  const ::ai::inworld::packets::AudioChunk& _internal_audio_chunk() const;
  ::ai::inworld::packets::AudioChunk* _internal_mutable_audio_chunk();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_audio_chunk(
      ::ai::inworld::packets::AudioChunk* audio_chunk);
  PROTOBUF_DEPRECATED ::ai::inworld::packets::AudioChunk* unsafe_arena_release_audio_chunk();

  // .ai.inworld.packets.CustomEvent custom = 8;
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::ai::inworld::packets::CustomEvent& custom() const;
  ::ai::inworld::packets::CustomEvent* release_custom();
  ::ai::inworld::packets::CustomEvent* mutable_custom();
  void set_allocated_custom(::ai::inworld::packets::CustomEvent* custom);
  private:
  const ::ai::inworld::packets::CustomEvent& _internal_custom() const;
  ::ai::inworld::packets::CustomEvent* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::ai::inworld::packets::CustomEvent* custom);
  ::ai::inworld::packets::CustomEvent* unsafe_arena_release_custom();

  // .ai.inworld.packets.CancelResponsesEvent cancelResponses = 10 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_cancelresponses() const;
  private:
  bool _internal_has_cancelresponses() const;
  public:
  PROTOBUF_DEPRECATED void clear_cancelresponses();
  PROTOBUF_DEPRECATED const ::ai::inworld::packets::CancelResponsesEvent& cancelresponses() const;
  PROTOBUF_DEPRECATED ::ai::inworld::packets::CancelResponsesEvent* release_cancelresponses();
  PROTOBUF_DEPRECATED ::ai::inworld::packets::CancelResponsesEvent* mutable_cancelresponses();
  PROTOBUF_DEPRECATED void set_allocated_cancelresponses(::ai::inworld::packets::CancelResponsesEvent* cancelresponses);
  private:
  const ::ai::inworld::packets::CancelResponsesEvent& _internal_cancelresponses() const;
  ::ai::inworld::packets::CancelResponsesEvent* _internal_mutable_cancelresponses();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_cancelresponses(
      ::ai::inworld::packets::CancelResponsesEvent* cancelresponses);
  PROTOBUF_DEPRECATED ::ai::inworld::packets::CancelResponsesEvent* unsafe_arena_release_cancelresponses();

  // .ai.inworld.packets.EmotionEvent emotion = 11;
  bool has_emotion() const;
  private:
  bool _internal_has_emotion() const;
  public:
  void clear_emotion();
  const ::ai::inworld::packets::EmotionEvent& emotion() const;
  ::ai::inworld::packets::EmotionEvent* release_emotion();
  ::ai::inworld::packets::EmotionEvent* mutable_emotion();
  void set_allocated_emotion(::ai::inworld::packets::EmotionEvent* emotion);
  private:
  const ::ai::inworld::packets::EmotionEvent& _internal_emotion() const;
  ::ai::inworld::packets::EmotionEvent* _internal_mutable_emotion();
  public:
  void unsafe_arena_set_allocated_emotion(
      ::ai::inworld::packets::EmotionEvent* emotion);
  ::ai::inworld::packets::EmotionEvent* unsafe_arena_release_emotion();

  // .ai.inworld.packets.DataChunk data_chunk = 12;
  bool has_data_chunk() const;
  private:
  bool _internal_has_data_chunk() const;
  public:
  void clear_data_chunk();
  const ::ai::inworld::packets::DataChunk& data_chunk() const;
  ::ai::inworld::packets::DataChunk* release_data_chunk();
  ::ai::inworld::packets::DataChunk* mutable_data_chunk();
  void set_allocated_data_chunk(::ai::inworld::packets::DataChunk* data_chunk);
  private:
  const ::ai::inworld::packets::DataChunk& _internal_data_chunk() const;
  ::ai::inworld::packets::DataChunk* _internal_mutable_data_chunk();
  public:
  void unsafe_arena_set_allocated_data_chunk(
      ::ai::inworld::packets::DataChunk* data_chunk);
  ::ai::inworld::packets::DataChunk* unsafe_arena_release_data_chunk();

  // .ai.inworld.packets.ActionEvent action = 13;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::ai::inworld::packets::ActionEvent& action() const;
  ::ai::inworld::packets::ActionEvent* release_action();
  ::ai::inworld::packets::ActionEvent* mutable_action();
  void set_allocated_action(::ai::inworld::packets::ActionEvent* action);
  private:
  const ::ai::inworld::packets::ActionEvent& _internal_action() const;
  ::ai::inworld::packets::ActionEvent* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::ai::inworld::packets::ActionEvent* action);
  ::ai::inworld::packets::ActionEvent* unsafe_arena_release_action();

  // .ai.inworld.packets.MutationEvent mutation = 15;
  bool has_mutation() const;
  private:
  bool _internal_has_mutation() const;
  public:
  void clear_mutation();
  const ::ai::inworld::packets::MutationEvent& mutation() const;
  ::ai::inworld::packets::MutationEvent* release_mutation();
  ::ai::inworld::packets::MutationEvent* mutable_mutation();
  void set_allocated_mutation(::ai::inworld::packets::MutationEvent* mutation);
  private:
  const ::ai::inworld::packets::MutationEvent& _internal_mutation() const;
  ::ai::inworld::packets::MutationEvent* _internal_mutable_mutation();
  public:
  void unsafe_arena_set_allocated_mutation(
      ::ai::inworld::packets::MutationEvent* mutation);
  ::ai::inworld::packets::MutationEvent* unsafe_arena_release_mutation();

  // .ai.inworld.packets.LoadSceneOutputEvent load_scene_output = 16;
  bool has_load_scene_output() const;
  private:
  bool _internal_has_load_scene_output() const;
  public:
  void clear_load_scene_output();
  const ::ai::inworld::packets::LoadSceneOutputEvent& load_scene_output() const;
  ::ai::inworld::packets::LoadSceneOutputEvent* release_load_scene_output();
  ::ai::inworld::packets::LoadSceneOutputEvent* mutable_load_scene_output();
  void set_allocated_load_scene_output(::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output);
  private:
  const ::ai::inworld::packets::LoadSceneOutputEvent& _internal_load_scene_output() const;
  ::ai::inworld::packets::LoadSceneOutputEvent* _internal_mutable_load_scene_output();
  public:
  void unsafe_arena_set_allocated_load_scene_output(
      ::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output);
  ::ai::inworld::packets::LoadSceneOutputEvent* unsafe_arena_release_load_scene_output();

  // .ai.inworld.packets.DebugInfoEvent debug_info = 18;
  bool has_debug_info() const;
  private:
  bool _internal_has_debug_info() const;
  public:
  void clear_debug_info();
  const ::ai::inworld::packets::DebugInfoEvent& debug_info() const;
  ::ai::inworld::packets::DebugInfoEvent* release_debug_info();
  ::ai::inworld::packets::DebugInfoEvent* mutable_debug_info();
  void set_allocated_debug_info(::ai::inworld::packets::DebugInfoEvent* debug_info);
  private:
  const ::ai::inworld::packets::DebugInfoEvent& _internal_debug_info() const;
  ::ai::inworld::packets::DebugInfoEvent* _internal_mutable_debug_info();
  public:
  void unsafe_arena_set_allocated_debug_info(
      ::ai::inworld::packets::DebugInfoEvent* debug_info);
  ::ai::inworld::packets::DebugInfoEvent* unsafe_arena_release_debug_info();

  void clear_packet();
  PacketCase packet_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.InworldPacket)
 private:
  class _Internal;
  void set_has_text();
  void set_has_control();
  void set_has_audio_chunk();
  void set_has_custom();
  void set_has_cancelresponses();
  void set_has_emotion();
  void set_has_data_chunk();
  void set_has_action();
  void set_has_mutation();
  void set_has_load_scene_output();
  void set_has_debug_info();

  inline bool has_packet() const;
  inline void clear_has_packet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  ::ai::inworld::packets::Routing* routing_;
  ::ai::inworld::packets::PacketId* packet_id_;
  union PacketUnion {
    PacketUnion() {}
    ::ai::inworld::packets::TextEvent* text_;
    ::ai::inworld::packets::ControlEvent* control_;
    ::ai::inworld::packets::AudioChunk* audio_chunk_;
    ::ai::inworld::packets::CustomEvent* custom_;
    ::ai::inworld::packets::CancelResponsesEvent* cancelresponses_;
    ::ai::inworld::packets::EmotionEvent* emotion_;
    ::ai::inworld::packets::DataChunk* data_chunk_;
    ::ai::inworld::packets::ActionEvent* action_;
    ::ai::inworld::packets::MutationEvent* mutation_;
    ::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output_;
    ::ai::inworld::packets::DebugInfoEvent* debug_info_;
  } packet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class TextEvent_ModelInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.TextEvent.ModelInfo) */ {
 public:
  inline TextEvent_ModelInfo() : TextEvent_ModelInfo(nullptr) {}
  virtual ~TextEvent_ModelInfo();

  TextEvent_ModelInfo(const TextEvent_ModelInfo& from);
  TextEvent_ModelInfo(TextEvent_ModelInfo&& from) noexcept
    : TextEvent_ModelInfo() {
    *this = ::std::move(from);
  }

  inline TextEvent_ModelInfo& operator=(const TextEvent_ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextEvent_ModelInfo& operator=(TextEvent_ModelInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextEvent_ModelInfo& default_instance();

  static inline const TextEvent_ModelInfo* internal_default_instance() {
    return reinterpret_cast<const TextEvent_ModelInfo*>(
               &_TextEvent_ModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TextEvent_ModelInfo& a, TextEvent_ModelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TextEvent_ModelInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextEvent_ModelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextEvent_ModelInfo* New() const final {
    return CreateMaybeMessage<TextEvent_ModelInfo>(nullptr);
  }

  TextEvent_ModelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextEvent_ModelInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextEvent_ModelInfo& from);
  void MergeFrom(const TextEvent_ModelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextEvent_ModelInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.TextEvent.ModelInfo";
  }
  protected:
  explicit TextEvent_ModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // string service = 1;
  void clear_service();
  const std::string& service() const;
  void set_service(const std::string& value);
  void set_service(std::string&& value);
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  std::string* mutable_service();
  std::string* release_service();
  void set_allocated_service(std::string* service);
  private:
  const std::string& _internal_service() const;
  void _internal_set_service(const std::string& value);
  std::string* _internal_mutable_service();
  public:

  // string model = 2;
  void clear_model();
  const std::string& model() const;
  void set_model(const std::string& value);
  void set_model(std::string&& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  std::string* mutable_model();
  std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.TextEvent.ModelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class TextEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.TextEvent) */ {
 public:
  inline TextEvent() : TextEvent(nullptr) {}
  virtual ~TextEvent();

  TextEvent(const TextEvent& from);
  TextEvent(TextEvent&& from) noexcept
    : TextEvent() {
    *this = ::std::move(from);
  }

  inline TextEvent& operator=(const TextEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextEvent& operator=(TextEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextEvent& default_instance();

  static inline const TextEvent* internal_default_instance() {
    return reinterpret_cast<const TextEvent*>(
               &_TextEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TextEvent& a, TextEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TextEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextEvent* New() const final {
    return CreateMaybeMessage<TextEvent>(nullptr);
  }

  TextEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextEvent& from);
  void MergeFrom(const TextEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.TextEvent";
  }
  protected:
  explicit TextEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TextEvent_ModelInfo ModelInfo;

  typedef TextEvent_SourceType SourceType;
  static constexpr SourceType UNKNOWN =
    TextEvent_SourceType_UNKNOWN;
  static constexpr SourceType SPEECH_TO_TEXT =
    TextEvent_SourceType_SPEECH_TO_TEXT;
  static constexpr SourceType TYPED_IN =
    TextEvent_SourceType_TYPED_IN;
  static constexpr SourceType GENERATED =
    TextEvent_SourceType_GENERATED;
  static constexpr SourceType FILLER =
    TextEvent_SourceType_FILLER;
  static inline bool SourceType_IsValid(int value) {
    return TextEvent_SourceType_IsValid(value);
  }
  static constexpr SourceType SourceType_MIN =
    TextEvent_SourceType_SourceType_MIN;
  static constexpr SourceType SourceType_MAX =
    TextEvent_SourceType_SourceType_MAX;
  static constexpr int SourceType_ARRAYSIZE =
    TextEvent_SourceType_SourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SourceType_descriptor() {
    return TextEvent_SourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& SourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SourceType_Name.");
    return TextEvent_SourceType_Name(enum_t_value);
  }
  static inline bool SourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SourceType* value) {
    return TextEvent_SourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kModelInfoFieldNumber = 4,
    kSourceTypeFieldNumber = 2,
    kFinalFieldNumber = 3,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .ai.inworld.packets.TextEvent.ModelInfo model_info = 4 [(.ai.inworld.options.field_mode) = HIDDEN];
  bool has_model_info() const;
  private:
  bool _internal_has_model_info() const;
  public:
  void clear_model_info();
  const ::ai::inworld::packets::TextEvent_ModelInfo& model_info() const;
  ::ai::inworld::packets::TextEvent_ModelInfo* release_model_info();
  ::ai::inworld::packets::TextEvent_ModelInfo* mutable_model_info();
  void set_allocated_model_info(::ai::inworld::packets::TextEvent_ModelInfo* model_info);
  private:
  const ::ai::inworld::packets::TextEvent_ModelInfo& _internal_model_info() const;
  ::ai::inworld::packets::TextEvent_ModelInfo* _internal_mutable_model_info();
  public:
  void unsafe_arena_set_allocated_model_info(
      ::ai::inworld::packets::TextEvent_ModelInfo* model_info);
  ::ai::inworld::packets::TextEvent_ModelInfo* unsafe_arena_release_model_info();

  // .ai.inworld.packets.TextEvent.SourceType source_type = 2;
  void clear_source_type();
  ::ai::inworld::packets::TextEvent_SourceType source_type() const;
  void set_source_type(::ai::inworld::packets::TextEvent_SourceType value);
  private:
  ::ai::inworld::packets::TextEvent_SourceType _internal_source_type() const;
  void _internal_set_source_type(::ai::inworld::packets::TextEvent_SourceType value);
  public:

  // bool final = 3;
  void clear_final();
  bool final() const;
  void set_final(bool value);
  private:
  bool _internal_final() const;
  void _internal_set_final(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.TextEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::ai::inworld::packets::TextEvent_ModelInfo* model_info_;
  int source_type_;
  bool final_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class ControlEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ControlEvent) */ {
 public:
  inline ControlEvent() : ControlEvent(nullptr) {}
  virtual ~ControlEvent();

  ControlEvent(const ControlEvent& from);
  ControlEvent(ControlEvent&& from) noexcept
    : ControlEvent() {
    *this = ::std::move(from);
  }

  inline ControlEvent& operator=(const ControlEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlEvent& operator=(ControlEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControlEvent& default_instance();

  static inline const ControlEvent* internal_default_instance() {
    return reinterpret_cast<const ControlEvent*>(
               &_ControlEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ControlEvent& a, ControlEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlEvent* New() const final {
    return CreateMaybeMessage<ControlEvent>(nullptr);
  }

  ControlEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControlEvent& from);
  void MergeFrom(const ControlEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ControlEvent";
  }
  protected:
  explicit ControlEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ControlEvent_Action Action;
  static constexpr Action UNKNOWN =
    ControlEvent_Action_UNKNOWN;
  static constexpr Action AUDIO_SESSION_START =
    ControlEvent_Action_AUDIO_SESSION_START;
  static constexpr Action AUDIO_SESSION_END =
    ControlEvent_Action_AUDIO_SESSION_END;
  static constexpr Action INTERACTION_END =
    ControlEvent_Action_INTERACTION_END;
  static constexpr Action TTS_PLAYBACK_START =
    ControlEvent_Action_TTS_PLAYBACK_START;
  static constexpr Action TTS_PLAYBACK_END =
    ControlEvent_Action_TTS_PLAYBACK_END;
  static constexpr Action TTS_PLAYBACK_MUTE =
    ControlEvent_Action_TTS_PLAYBACK_MUTE;
  static constexpr Action TTS_PLAYBACK_UNMUTE =
    ControlEvent_Action_TTS_PLAYBACK_UNMUTE;
  static constexpr Action WARNING =
    ControlEvent_Action_WARNING;
  static constexpr Action SESSION_END =
    ControlEvent_Action_SESSION_END;
  static inline bool Action_IsValid(int value) {
    return ControlEvent_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    ControlEvent_Action_Action_MIN;
  static constexpr Action Action_MAX =
    ControlEvent_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    ControlEvent_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return ControlEvent_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return ControlEvent_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return ControlEvent_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kPayloadFieldNumber = 3,
    kActionFieldNumber = 1,
  };
  // string description = 2;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .google.protobuf.Struct payload = 3;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const PROTOBUF_NAMESPACE_ID::Struct& payload() const;
  PROTOBUF_NAMESPACE_ID::Struct* release_payload();
  PROTOBUF_NAMESPACE_ID::Struct* mutable_payload();
  void set_allocated_payload(PROTOBUF_NAMESPACE_ID::Struct* payload);
  private:
  const PROTOBUF_NAMESPACE_ID::Struct& _internal_payload() const;
  PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      PROTOBUF_NAMESPACE_ID::Struct* payload);
  PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_payload();

  // .ai.inworld.packets.ControlEvent.Action action = 1;
  void clear_action();
  ::ai::inworld::packets::ControlEvent_Action action() const;
  void set_action(::ai::inworld::packets::ControlEvent_Action value);
  private:
  ::ai::inworld::packets::ControlEvent_Action _internal_action() const;
  void _internal_set_action(::ai::inworld::packets::ControlEvent_Action value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ControlEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  PROTOBUF_NAMESPACE_ID::Struct* payload_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class AudioChunk PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.AudioChunk) */ {
 public:
  inline AudioChunk() : AudioChunk(nullptr) {}
  virtual ~AudioChunk();

  AudioChunk(const AudioChunk& from);
  AudioChunk(AudioChunk&& from) noexcept
    : AudioChunk() {
    *this = ::std::move(from);
  }

  inline AudioChunk& operator=(const AudioChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioChunk& operator=(AudioChunk&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioChunk& default_instance();

  static inline const AudioChunk* internal_default_instance() {
    return reinterpret_cast<const AudioChunk*>(
               &_AudioChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AudioChunk& a, AudioChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioChunk* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioChunk* New() const final {
    return CreateMaybeMessage<AudioChunk>(nullptr);
  }

  AudioChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioChunk>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioChunk& from);
  void MergeFrom(const AudioChunk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioChunk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.AudioChunk";
  }
  protected:
  explicit AudioChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkFieldNumber = 1,
  };
  // bytes chunk = 1;
  void clear_chunk();
  const std::string& chunk() const;
  void set_chunk(const std::string& value);
  void set_chunk(std::string&& value);
  void set_chunk(const char* value);
  void set_chunk(const void* value, size_t size);
  std::string* mutable_chunk();
  std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.AudioChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class CustomEvent_Parameter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CustomEvent.Parameter) */ {
 public:
  inline CustomEvent_Parameter() : CustomEvent_Parameter(nullptr) {}
  virtual ~CustomEvent_Parameter();

  CustomEvent_Parameter(const CustomEvent_Parameter& from);
  CustomEvent_Parameter(CustomEvent_Parameter&& from) noexcept
    : CustomEvent_Parameter() {
    *this = ::std::move(from);
  }

  inline CustomEvent_Parameter& operator=(const CustomEvent_Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomEvent_Parameter& operator=(CustomEvent_Parameter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CustomEvent_Parameter& default_instance();

  static inline const CustomEvent_Parameter* internal_default_instance() {
    return reinterpret_cast<const CustomEvent_Parameter*>(
               &_CustomEvent_Parameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CustomEvent_Parameter& a, CustomEvent_Parameter& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomEvent_Parameter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomEvent_Parameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomEvent_Parameter* New() const final {
    return CreateMaybeMessage<CustomEvent_Parameter>(nullptr);
  }

  CustomEvent_Parameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomEvent_Parameter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CustomEvent_Parameter& from);
  void MergeFrom(const CustomEvent_Parameter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomEvent_Parameter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CustomEvent.Parameter";
  }
  protected:
  explicit CustomEvent_Parameter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CustomEvent.Parameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class CustomEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CustomEvent) */ {
 public:
  inline CustomEvent() : CustomEvent(nullptr) {}
  virtual ~CustomEvent();

  CustomEvent(const CustomEvent& from);
  CustomEvent(CustomEvent&& from) noexcept
    : CustomEvent() {
    *this = ::std::move(from);
  }

  inline CustomEvent& operator=(const CustomEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomEvent& operator=(CustomEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CustomEvent& default_instance();

  static inline const CustomEvent* internal_default_instance() {
    return reinterpret_cast<const CustomEvent*>(
               &_CustomEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CustomEvent& a, CustomEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CustomEvent* New() const final {
    return CreateMaybeMessage<CustomEvent>(nullptr);
  }

  CustomEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CustomEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CustomEvent& from);
  void MergeFrom(const CustomEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CustomEvent";
  }
  protected:
  explicit CustomEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CustomEvent_Parameter Parameter;

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kNameFieldNumber = 1,
    kPlaybackFieldNumber = 2,
  };
  // repeated .ai.inworld.packets.CustomEvent.Parameter parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::ai::inworld::packets::CustomEvent_Parameter* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >*
      mutable_parameters();
  private:
  const ::ai::inworld::packets::CustomEvent_Parameter& _internal_parameters(int index) const;
  ::ai::inworld::packets::CustomEvent_Parameter* _internal_add_parameters();
  public:
  const ::ai::inworld::packets::CustomEvent_Parameter& parameters(int index) const;
  ::ai::inworld::packets::CustomEvent_Parameter* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >&
      parameters() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ai.inworld.packets.Playback playback = 2;
  void clear_playback();
  ::ai::inworld::packets::Playback playback() const;
  void set_playback(::ai::inworld::packets::Playback value);
  private:
  ::ai::inworld::packets::Playback _internal_playback() const;
  void _internal_set_playback(::ai::inworld::packets::Playback value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CustomEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int playback_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class CancelResponsesEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CancelResponsesEvent) */ {
 public:
  inline CancelResponsesEvent() : CancelResponsesEvent(nullptr) {}
  virtual ~CancelResponsesEvent();

  CancelResponsesEvent(const CancelResponsesEvent& from);
  CancelResponsesEvent(CancelResponsesEvent&& from) noexcept
    : CancelResponsesEvent() {
    *this = ::std::move(from);
  }

  inline CancelResponsesEvent& operator=(const CancelResponsesEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponsesEvent& operator=(CancelResponsesEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CancelResponsesEvent& default_instance();

  static inline const CancelResponsesEvent* internal_default_instance() {
    return reinterpret_cast<const CancelResponsesEvent*>(
               &_CancelResponsesEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CancelResponsesEvent& a, CancelResponsesEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponsesEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponsesEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelResponsesEvent* New() const final {
    return CreateMaybeMessage<CancelResponsesEvent>(nullptr);
  }

  CancelResponsesEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelResponsesEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CancelResponsesEvent& from);
  void MergeFrom(const CancelResponsesEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelResponsesEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CancelResponsesEvent";
  }
  protected:
  explicit CancelResponsesEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 1,
  };
  // repeated string utterance_id = 2;
  int utterance_id_size() const;
  private:
  int _internal_utterance_id_size() const;
  public:
  void clear_utterance_id();
  const std::string& utterance_id(int index) const;
  std::string* mutable_utterance_id(int index);
  void set_utterance_id(int index, const std::string& value);
  void set_utterance_id(int index, std::string&& value);
  void set_utterance_id(int index, const char* value);
  void set_utterance_id(int index, const char* value, size_t size);
  std::string* add_utterance_id();
  void add_utterance_id(const std::string& value);
  void add_utterance_id(std::string&& value);
  void add_utterance_id(const char* value);
  void add_utterance_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& utterance_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_utterance_id();
  private:
  const std::string& _internal_utterance_id(int index) const;
  std::string* _internal_add_utterance_id();
  public:

  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CancelResponsesEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> utterance_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class EmotionEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.EmotionEvent) */ {
 public:
  inline EmotionEvent() : EmotionEvent(nullptr) {}
  virtual ~EmotionEvent();

  EmotionEvent(const EmotionEvent& from);
  EmotionEvent(EmotionEvent&& from) noexcept
    : EmotionEvent() {
    *this = ::std::move(from);
  }

  inline EmotionEvent& operator=(const EmotionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmotionEvent& operator=(EmotionEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmotionEvent& default_instance();

  static inline const EmotionEvent* internal_default_instance() {
    return reinterpret_cast<const EmotionEvent*>(
               &_EmotionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EmotionEvent& a, EmotionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(EmotionEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmotionEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmotionEvent* New() const final {
    return CreateMaybeMessage<EmotionEvent>(nullptr);
  }

  EmotionEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmotionEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmotionEvent& from);
  void MergeFrom(const EmotionEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmotionEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.EmotionEvent";
  }
  protected:
  explicit EmotionEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EmotionEvent_SpaffCode SpaffCode;
  static constexpr SpaffCode NEUTRAL =
    EmotionEvent_SpaffCode_NEUTRAL;
  static constexpr SpaffCode DISGUST =
    EmotionEvent_SpaffCode_DISGUST;
  static constexpr SpaffCode CONTEMPT =
    EmotionEvent_SpaffCode_CONTEMPT;
  static constexpr SpaffCode BELLIGERENCE =
    EmotionEvent_SpaffCode_BELLIGERENCE;
  static constexpr SpaffCode DOMINEERING =
    EmotionEvent_SpaffCode_DOMINEERING;
  static constexpr SpaffCode CRITICISM =
    EmotionEvent_SpaffCode_CRITICISM;
  static constexpr SpaffCode ANGER =
    EmotionEvent_SpaffCode_ANGER;
  static constexpr SpaffCode TENSION =
    EmotionEvent_SpaffCode_TENSION;
  static constexpr SpaffCode TENSE_HUMOR =
    EmotionEvent_SpaffCode_TENSE_HUMOR;
  static constexpr SpaffCode DEFENSIVENESS =
    EmotionEvent_SpaffCode_DEFENSIVENESS;
  static constexpr SpaffCode WHINING =
    EmotionEvent_SpaffCode_WHINING;
  static constexpr SpaffCode SADNESS =
    EmotionEvent_SpaffCode_SADNESS;
  static constexpr SpaffCode STONEWALLING =
    EmotionEvent_SpaffCode_STONEWALLING;
  static constexpr SpaffCode INTEREST =
    EmotionEvent_SpaffCode_INTEREST;
  static constexpr SpaffCode VALIDATION =
    EmotionEvent_SpaffCode_VALIDATION;
  static constexpr SpaffCode AFFECTION =
    EmotionEvent_SpaffCode_AFFECTION;
  static constexpr SpaffCode HUMOR =
    EmotionEvent_SpaffCode_HUMOR;
  static constexpr SpaffCode SURPRISE =
    EmotionEvent_SpaffCode_SURPRISE;
  static constexpr SpaffCode JOY =
    EmotionEvent_SpaffCode_JOY;
  static inline bool SpaffCode_IsValid(int value) {
    return EmotionEvent_SpaffCode_IsValid(value);
  }
  static constexpr SpaffCode SpaffCode_MIN =
    EmotionEvent_SpaffCode_SpaffCode_MIN;
  static constexpr SpaffCode SpaffCode_MAX =
    EmotionEvent_SpaffCode_SpaffCode_MAX;
  static constexpr int SpaffCode_ARRAYSIZE =
    EmotionEvent_SpaffCode_SpaffCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SpaffCode_descriptor() {
    return EmotionEvent_SpaffCode_descriptor();
  }
  template<typename T>
  static inline const std::string& SpaffCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SpaffCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SpaffCode_Name.");
    return EmotionEvent_SpaffCode_Name(enum_t_value);
  }
  static inline bool SpaffCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SpaffCode* value) {
    return EmotionEvent_SpaffCode_Parse(name, value);
  }

  typedef EmotionEvent_Strength Strength;
  static constexpr Strength UNSPECIFIED =
    EmotionEvent_Strength_UNSPECIFIED;
  static constexpr Strength WEAK =
    EmotionEvent_Strength_WEAK;
  static constexpr Strength STRONG =
    EmotionEvent_Strength_STRONG;
  static constexpr Strength NORMAL =
    EmotionEvent_Strength_NORMAL;
  static inline bool Strength_IsValid(int value) {
    return EmotionEvent_Strength_IsValid(value);
  }
  static constexpr Strength Strength_MIN =
    EmotionEvent_Strength_Strength_MIN;
  static constexpr Strength Strength_MAX =
    EmotionEvent_Strength_Strength_MAX;
  static constexpr int Strength_ARRAYSIZE =
    EmotionEvent_Strength_Strength_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Strength_descriptor() {
    return EmotionEvent_Strength_descriptor();
  }
  template<typename T>
  static inline const std::string& Strength_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Strength>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Strength_Name.");
    return EmotionEvent_Strength_Name(enum_t_value);
  }
  static inline bool Strength_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Strength* value) {
    return EmotionEvent_Strength_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJoyFieldNumber = 1,
    kFearFieldNumber = 2,
    kTrustFieldNumber = 3,
    kSurpriseFieldNumber = 4,
    kBehaviorFieldNumber = 5,
    kStrengthFieldNumber = 6,
  };
  // float joy = 1;
  void clear_joy();
  float joy() const;
  void set_joy(float value);
  private:
  float _internal_joy() const;
  void _internal_set_joy(float value);
  public:

  // float fear = 2;
  void clear_fear();
  float fear() const;
  void set_fear(float value);
  private:
  float _internal_fear() const;
  void _internal_set_fear(float value);
  public:

  // float trust = 3;
  void clear_trust();
  float trust() const;
  void set_trust(float value);
  private:
  float _internal_trust() const;
  void _internal_set_trust(float value);
  public:

  // float surprise = 4;
  void clear_surprise();
  float surprise() const;
  void set_surprise(float value);
  private:
  float _internal_surprise() const;
  void _internal_set_surprise(float value);
  public:

  // .ai.inworld.packets.EmotionEvent.SpaffCode behavior = 5;
  void clear_behavior();
  ::ai::inworld::packets::EmotionEvent_SpaffCode behavior() const;
  void set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value);
  private:
  ::ai::inworld::packets::EmotionEvent_SpaffCode _internal_behavior() const;
  void _internal_set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value);
  public:

  // .ai.inworld.packets.EmotionEvent.Strength strength = 6;
  void clear_strength();
  ::ai::inworld::packets::EmotionEvent_Strength strength() const;
  void set_strength(::ai::inworld::packets::EmotionEvent_Strength value);
  private:
  ::ai::inworld::packets::EmotionEvent_Strength _internal_strength() const;
  void _internal_set_strength(::ai::inworld::packets::EmotionEvent_Strength value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.EmotionEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float joy_;
  float fear_;
  float trust_;
  float surprise_;
  int behavior_;
  int strength_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class DataChunk PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DataChunk) */ {
 public:
  inline DataChunk() : DataChunk(nullptr) {}
  virtual ~DataChunk();

  DataChunk(const DataChunk& from);
  DataChunk(DataChunk&& from) noexcept
    : DataChunk() {
    *this = ::std::move(from);
  }

  inline DataChunk& operator=(const DataChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChunk& operator=(DataChunk&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataChunk& default_instance();

  enum DataCase {
    kChunk = 1,
    kDurationMs = 3,
    DATA_NOT_SET = 0,
  };

  static inline const DataChunk* internal_default_instance() {
    return reinterpret_cast<const DataChunk*>(
               &_DataChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DataChunk& a, DataChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(DataChunk* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataChunk* New() const final {
    return CreateMaybeMessage<DataChunk>(nullptr);
  }

  DataChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataChunk>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataChunk& from);
  void MergeFrom(const DataChunk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataChunk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.DataChunk";
  }
  protected:
  explicit DataChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DataChunk_DataType DataType;
  static constexpr DataType UNSPECIFIED =
    DataChunk_DataType_UNSPECIFIED;
  static constexpr DataType AUDIO =
    DataChunk_DataType_AUDIO;
  static constexpr DataType SILENCE =
    DataChunk_DataType_SILENCE;
  static constexpr DataType STATE =
    DataChunk_DataType_STATE;
  static inline bool DataType_IsValid(int value) {
    return DataChunk_DataType_IsValid(value);
  }
  static constexpr DataType DataType_MIN =
    DataChunk_DataType_DataType_MIN;
  static constexpr DataType DataType_MAX =
    DataChunk_DataType_DataType_MAX;
  static constexpr int DataType_ARRAYSIZE =
    DataChunk_DataType_DataType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataType_descriptor() {
    return DataChunk_DataType_descriptor();
  }
  template<typename T>
  static inline const std::string& DataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataType_Name.");
    return DataChunk_DataType_Name(enum_t_value);
  }
  static inline bool DataType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DataType* value) {
    return DataChunk_DataType_Parse(name, value);
  }

  typedef DataChunk_AudioFormat AudioFormat;
  static constexpr AudioFormat UNSPECIFIED_AUDIO_FORMAT =
    DataChunk_AudioFormat_UNSPECIFIED_AUDIO_FORMAT;
  static constexpr AudioFormat AUDIO_MP3 =
    DataChunk_AudioFormat_AUDIO_MP3;
  static constexpr AudioFormat AUDIO_PCM_16000 =
    DataChunk_AudioFormat_AUDIO_PCM_16000;
  static constexpr AudioFormat AUDIO_PCM_22050 =
    DataChunk_AudioFormat_AUDIO_PCM_22050;
  static inline bool AudioFormat_IsValid(int value) {
    return DataChunk_AudioFormat_IsValid(value);
  }
  static constexpr AudioFormat AudioFormat_MIN =
    DataChunk_AudioFormat_AudioFormat_MIN;
  static constexpr AudioFormat AudioFormat_MAX =
    DataChunk_AudioFormat_AudioFormat_MAX;
  static constexpr int AudioFormat_ARRAYSIZE =
    DataChunk_AudioFormat_AudioFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AudioFormat_descriptor() {
    return DataChunk_AudioFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& AudioFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AudioFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AudioFormat_Name.");
    return DataChunk_AudioFormat_Name(enum_t_value);
  }
  static inline bool AudioFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AudioFormat* value) {
    return DataChunk_AudioFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalPhonemeInfoFieldNumber = 4,
    kTypeFieldNumber = 2,
    kAudioFormatFieldNumber = 5,
    kChunkFieldNumber = 1,
    kDurationMsFieldNumber = 3,
  };
  // repeated .ai.inworld.packets.AdditionalPhonemeInfo additional_phoneme_info = 4;
  int additional_phoneme_info_size() const;
  private:
  int _internal_additional_phoneme_info_size() const;
  public:
  void clear_additional_phoneme_info();
  ::ai::inworld::packets::AdditionalPhonemeInfo* mutable_additional_phoneme_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >*
      mutable_additional_phoneme_info();
  private:
  const ::ai::inworld::packets::AdditionalPhonemeInfo& _internal_additional_phoneme_info(int index) const;
  ::ai::inworld::packets::AdditionalPhonemeInfo* _internal_add_additional_phoneme_info();
  public:
  const ::ai::inworld::packets::AdditionalPhonemeInfo& additional_phoneme_info(int index) const;
  ::ai::inworld::packets::AdditionalPhonemeInfo* add_additional_phoneme_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >&
      additional_phoneme_info() const;

  // .ai.inworld.packets.DataChunk.DataType type = 2;
  void clear_type();
  ::ai::inworld::packets::DataChunk_DataType type() const;
  void set_type(::ai::inworld::packets::DataChunk_DataType value);
  private:
  ::ai::inworld::packets::DataChunk_DataType _internal_type() const;
  void _internal_set_type(::ai::inworld::packets::DataChunk_DataType value);
  public:

  // .ai.inworld.packets.DataChunk.AudioFormat audioFormat = 5;
  void clear_audioformat();
  ::ai::inworld::packets::DataChunk_AudioFormat audioformat() const;
  void set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value);
  private:
  ::ai::inworld::packets::DataChunk_AudioFormat _internal_audioformat() const;
  void _internal_set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value);
  public:

  // bytes chunk = 1;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const std::string& chunk() const;
  void set_chunk(const std::string& value);
  void set_chunk(std::string&& value);
  void set_chunk(const char* value);
  void set_chunk(const void* value, size_t size);
  std::string* mutable_chunk();
  std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  // int64 duration_ms = 3;
  private:
  bool _internal_has_duration_ms() const;
  public:
  void clear_duration_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 duration_ms() const;
  void set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_duration_ms() const;
  void _internal_set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DataChunk)
 private:
  class _Internal;
  void set_has_chunk();
  void set_has_duration_ms();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo > additional_phoneme_info_;
  int type_;
  int audioformat_;
  union DataUnion {
    DataUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
    ::PROTOBUF_NAMESPACE_ID::int64 duration_ms_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class AdditionalPhonemeInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.AdditionalPhonemeInfo) */ {
 public:
  inline AdditionalPhonemeInfo() : AdditionalPhonemeInfo(nullptr) {}
  virtual ~AdditionalPhonemeInfo();

  AdditionalPhonemeInfo(const AdditionalPhonemeInfo& from);
  AdditionalPhonemeInfo(AdditionalPhonemeInfo&& from) noexcept
    : AdditionalPhonemeInfo() {
    *this = ::std::move(from);
  }

  inline AdditionalPhonemeInfo& operator=(const AdditionalPhonemeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalPhonemeInfo& operator=(AdditionalPhonemeInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdditionalPhonemeInfo& default_instance();

  static inline const AdditionalPhonemeInfo* internal_default_instance() {
    return reinterpret_cast<const AdditionalPhonemeInfo*>(
               &_AdditionalPhonemeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AdditionalPhonemeInfo& a, AdditionalPhonemeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AdditionalPhonemeInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalPhonemeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdditionalPhonemeInfo* New() const final {
    return CreateMaybeMessage<AdditionalPhonemeInfo>(nullptr);
  }

  AdditionalPhonemeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdditionalPhonemeInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdditionalPhonemeInfo& from);
  void MergeFrom(const AdditionalPhonemeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdditionalPhonemeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.AdditionalPhonemeInfo";
  }
  protected:
  explicit AdditionalPhonemeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhonemeFieldNumber = 1,
    kStartOffsetFieldNumber = 2,
  };
  // string phoneme = 1;
  void clear_phoneme();
  const std::string& phoneme() const;
  void set_phoneme(const std::string& value);
  void set_phoneme(std::string&& value);
  void set_phoneme(const char* value);
  void set_phoneme(const char* value, size_t size);
  std::string* mutable_phoneme();
  std::string* release_phoneme();
  void set_allocated_phoneme(std::string* phoneme);
  private:
  const std::string& _internal_phoneme() const;
  void _internal_set_phoneme(const std::string& value);
  std::string* _internal_mutable_phoneme();
  public:

  // .google.protobuf.Duration start_offset = 2;
  bool has_start_offset() const;
  private:
  bool _internal_has_start_offset() const;
  public:
  void clear_start_offset();
  const PROTOBUF_NAMESPACE_ID::Duration& start_offset() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_start_offset();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_start_offset();
  void set_allocated_start_offset(PROTOBUF_NAMESPACE_ID::Duration* start_offset);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_start_offset() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_start_offset();
  public:
  void unsafe_arena_set_allocated_start_offset(
      PROTOBUF_NAMESPACE_ID::Duration* start_offset);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_start_offset();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.AdditionalPhonemeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phoneme_;
  PROTOBUF_NAMESPACE_ID::Duration* start_offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class ActionEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ActionEvent) */ {
 public:
  inline ActionEvent() : ActionEvent(nullptr) {}
  virtual ~ActionEvent();

  ActionEvent(const ActionEvent& from);
  ActionEvent(ActionEvent&& from) noexcept
    : ActionEvent() {
    *this = ::std::move(from);
  }

  inline ActionEvent& operator=(const ActionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionEvent& operator=(ActionEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionEvent& default_instance();

  enum ActionCase {
    kNarratedAction = 1,
    ACTION_NOT_SET = 0,
  };

  static inline const ActionEvent* internal_default_instance() {
    return reinterpret_cast<const ActionEvent*>(
               &_ActionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ActionEvent& a, ActionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionEvent* New() const final {
    return CreateMaybeMessage<ActionEvent>(nullptr);
  }

  ActionEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionEvent& from);
  void MergeFrom(const ActionEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ActionEvent";
  }
  protected:
  explicit ActionEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaybackFieldNumber = 2,
    kNarratedActionFieldNumber = 1,
  };
  // .ai.inworld.packets.Playback playback = 2;
  void clear_playback();
  ::ai::inworld::packets::Playback playback() const;
  void set_playback(::ai::inworld::packets::Playback value);
  private:
  ::ai::inworld::packets::Playback _internal_playback() const;
  void _internal_set_playback(::ai::inworld::packets::Playback value);
  public:

  // .ai.inworld.packets.NarratedAction narrated_action = 1;
  bool has_narrated_action() const;
  private:
  bool _internal_has_narrated_action() const;
  public:
  void clear_narrated_action();
  const ::ai::inworld::packets::NarratedAction& narrated_action() const;
  ::ai::inworld::packets::NarratedAction* release_narrated_action();
  ::ai::inworld::packets::NarratedAction* mutable_narrated_action();
  void set_allocated_narrated_action(::ai::inworld::packets::NarratedAction* narrated_action);
  private:
  const ::ai::inworld::packets::NarratedAction& _internal_narrated_action() const;
  ::ai::inworld::packets::NarratedAction* _internal_mutable_narrated_action();
  public:
  void unsafe_arena_set_allocated_narrated_action(
      ::ai::inworld::packets::NarratedAction* narrated_action);
  ::ai::inworld::packets::NarratedAction* unsafe_arena_release_narrated_action();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ActionEvent)
 private:
  class _Internal;
  void set_has_narrated_action();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int playback_;
  union ActionUnion {
    ActionUnion() {}
    ::ai::inworld::packets::NarratedAction* narrated_action_;
  } action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class NarratedAction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.NarratedAction) */ {
 public:
  inline NarratedAction() : NarratedAction(nullptr) {}
  virtual ~NarratedAction();

  NarratedAction(const NarratedAction& from);
  NarratedAction(NarratedAction&& from) noexcept
    : NarratedAction() {
    *this = ::std::move(from);
  }

  inline NarratedAction& operator=(const NarratedAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline NarratedAction& operator=(NarratedAction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NarratedAction& default_instance();

  static inline const NarratedAction* internal_default_instance() {
    return reinterpret_cast<const NarratedAction*>(
               &_NarratedAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NarratedAction& a, NarratedAction& b) {
    a.Swap(&b);
  }
  inline void Swap(NarratedAction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NarratedAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NarratedAction* New() const final {
    return CreateMaybeMessage<NarratedAction>(nullptr);
  }

  NarratedAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NarratedAction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NarratedAction& from);
  void MergeFrom(const NarratedAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NarratedAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.NarratedAction";
  }
  protected:
  explicit NarratedAction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.NarratedAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class RelationInfo_RelationAttributes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RelationInfo.RelationAttributes) */ {
 public:
  inline RelationInfo_RelationAttributes() : RelationInfo_RelationAttributes(nullptr) {}
  virtual ~RelationInfo_RelationAttributes();

  RelationInfo_RelationAttributes(const RelationInfo_RelationAttributes& from);
  RelationInfo_RelationAttributes(RelationInfo_RelationAttributes&& from) noexcept
    : RelationInfo_RelationAttributes() {
    *this = ::std::move(from);
  }

  inline RelationInfo_RelationAttributes& operator=(const RelationInfo_RelationAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationInfo_RelationAttributes& operator=(RelationInfo_RelationAttributes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RelationInfo_RelationAttributes& default_instance();

  static inline const RelationInfo_RelationAttributes* internal_default_instance() {
    return reinterpret_cast<const RelationInfo_RelationAttributes*>(
               &_RelationInfo_RelationAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RelationInfo_RelationAttributes& a, RelationInfo_RelationAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationInfo_RelationAttributes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationInfo_RelationAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelationInfo_RelationAttributes* New() const final {
    return CreateMaybeMessage<RelationInfo_RelationAttributes>(nullptr);
  }

  RelationInfo_RelationAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelationInfo_RelationAttributes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RelationInfo_RelationAttributes& from);
  void MergeFrom(const RelationInfo_RelationAttributes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationInfo_RelationAttributes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.RelationInfo.RelationAttributes";
  }
  protected:
  explicit RelationInfo_RelationAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrustFieldNumber = 1,
    kRespectFieldNumber = 2,
    kFamiliarFieldNumber = 3,
    kFlirtatiousFieldNumber = 4,
    kAttractionFieldNumber = 5,
  };
  // int32 trust = 1;
  void clear_trust();
  ::PROTOBUF_NAMESPACE_ID::int32 trust() const;
  void set_trust(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trust() const;
  void _internal_set_trust(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 respect = 2;
  void clear_respect();
  ::PROTOBUF_NAMESPACE_ID::int32 respect() const;
  void set_respect(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_respect() const;
  void _internal_set_respect(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 familiar = 3;
  void clear_familiar();
  ::PROTOBUF_NAMESPACE_ID::int32 familiar() const;
  void set_familiar(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_familiar() const;
  void _internal_set_familiar(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 flirtatious = 4;
  void clear_flirtatious();
  ::PROTOBUF_NAMESPACE_ID::int32 flirtatious() const;
  void set_flirtatious(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_flirtatious() const;
  void _internal_set_flirtatious(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 attraction = 5;
  void clear_attraction();
  ::PROTOBUF_NAMESPACE_ID::int32 attraction() const;
  void set_attraction(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attraction() const;
  void _internal_set_attraction(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RelationInfo.RelationAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 trust_;
  ::PROTOBUF_NAMESPACE_ID::int32 respect_;
  ::PROTOBUF_NAMESPACE_ID::int32 familiar_;
  ::PROTOBUF_NAMESPACE_ID::int32 flirtatious_;
  ::PROTOBUF_NAMESPACE_ID::int32 attraction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class RelationInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RelationInfo) */ {
 public:
  inline RelationInfo() : RelationInfo(nullptr) {}
  virtual ~RelationInfo();

  RelationInfo(const RelationInfo& from);
  RelationInfo(RelationInfo&& from) noexcept
    : RelationInfo() {
    *this = ::std::move(from);
  }

  inline RelationInfo& operator=(const RelationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationInfo& operator=(RelationInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RelationInfo& default_instance();

  static inline const RelationInfo* internal_default_instance() {
    return reinterpret_cast<const RelationInfo*>(
               &_RelationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RelationInfo& a, RelationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelationInfo* New() const final {
    return CreateMaybeMessage<RelationInfo>(nullptr);
  }

  RelationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelationInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RelationInfo& from);
  void MergeFrom(const RelationInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.RelationInfo";
  }
  protected:
  explicit RelationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RelationInfo_RelationAttributes RelationAttributes;

  // accessors -------------------------------------------------------

  enum : int {
    kRelationStateFieldNumber = 1,
    kRelationUpdateFieldNumber = 2,
  };
  // .ai.inworld.packets.RelationInfo.RelationAttributes relation_state = 1;
  bool has_relation_state() const;
  private:
  bool _internal_has_relation_state() const;
  public:
  void clear_relation_state();
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& relation_state() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* release_relation_state();
  ::ai::inworld::packets::RelationInfo_RelationAttributes* mutable_relation_state();
  void set_allocated_relation_state(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state);
  private:
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& _internal_relation_state() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _internal_mutable_relation_state();
  public:
  void unsafe_arena_set_allocated_relation_state(
      ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state);
  ::ai::inworld::packets::RelationInfo_RelationAttributes* unsafe_arena_release_relation_state();

  // .ai.inworld.packets.RelationInfo.RelationAttributes relation_update = 2;
  bool has_relation_update() const;
  private:
  bool _internal_has_relation_update() const;
  public:
  void clear_relation_update();
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& relation_update() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* release_relation_update();
  ::ai::inworld::packets::RelationInfo_RelationAttributes* mutable_relation_update();
  void set_allocated_relation_update(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update);
  private:
  const ::ai::inworld::packets::RelationInfo_RelationAttributes& _internal_relation_update() const;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* _internal_mutable_relation_update();
  public:
  void unsafe_arena_set_allocated_relation_update(
      ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update);
  ::ai::inworld::packets::RelationInfo_RelationAttributes* unsafe_arena_release_relation_update();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RelationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state_;
  ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class MutationEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.MutationEvent) */ {
 public:
  inline MutationEvent() : MutationEvent(nullptr) {}
  virtual ~MutationEvent();

  MutationEvent(const MutationEvent& from);
  MutationEvent(MutationEvent&& from) noexcept
    : MutationEvent() {
    *this = ::std::move(from);
  }

  inline MutationEvent& operator=(const MutationEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutationEvent& operator=(MutationEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MutationEvent& default_instance();

  enum MutationCase {
    kCancelResponses = 1,
    kRegenerateResponse = 2,
    kApplyResponse = 3,
    kLoadScene = 4,
    kModifyExactResponse = 5,
    MUTATION_NOT_SET = 0,
  };

  static inline const MutationEvent* internal_default_instance() {
    return reinterpret_cast<const MutationEvent*>(
               &_MutationEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(MutationEvent& a, MutationEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MutationEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MutationEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MutationEvent* New() const final {
    return CreateMaybeMessage<MutationEvent>(nullptr);
  }

  MutationEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MutationEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MutationEvent& from);
  void MergeFrom(const MutationEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutationEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.MutationEvent";
  }
  protected:
  explicit MutationEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCancelResponsesFieldNumber = 1,
    kRegenerateResponseFieldNumber = 2,
    kApplyResponseFieldNumber = 3,
    kLoadSceneFieldNumber = 4,
    kModifyExactResponseFieldNumber = 5,
  };
  // .ai.inworld.packets.CancelResponses cancel_responses = 1;
  bool has_cancel_responses() const;
  private:
  bool _internal_has_cancel_responses() const;
  public:
  void clear_cancel_responses();
  const ::ai::inworld::packets::CancelResponses& cancel_responses() const;
  ::ai::inworld::packets::CancelResponses* release_cancel_responses();
  ::ai::inworld::packets::CancelResponses* mutable_cancel_responses();
  void set_allocated_cancel_responses(::ai::inworld::packets::CancelResponses* cancel_responses);
  private:
  const ::ai::inworld::packets::CancelResponses& _internal_cancel_responses() const;
  ::ai::inworld::packets::CancelResponses* _internal_mutable_cancel_responses();
  public:
  void unsafe_arena_set_allocated_cancel_responses(
      ::ai::inworld::packets::CancelResponses* cancel_responses);
  ::ai::inworld::packets::CancelResponses* unsafe_arena_release_cancel_responses();

  // .ai.inworld.packets.RegenerateResponse regenerate_response = 2;
  bool has_regenerate_response() const;
  private:
  bool _internal_has_regenerate_response() const;
  public:
  void clear_regenerate_response();
  const ::ai::inworld::packets::RegenerateResponse& regenerate_response() const;
  ::ai::inworld::packets::RegenerateResponse* release_regenerate_response();
  ::ai::inworld::packets::RegenerateResponse* mutable_regenerate_response();
  void set_allocated_regenerate_response(::ai::inworld::packets::RegenerateResponse* regenerate_response);
  private:
  const ::ai::inworld::packets::RegenerateResponse& _internal_regenerate_response() const;
  ::ai::inworld::packets::RegenerateResponse* _internal_mutable_regenerate_response();
  public:
  void unsafe_arena_set_allocated_regenerate_response(
      ::ai::inworld::packets::RegenerateResponse* regenerate_response);
  ::ai::inworld::packets::RegenerateResponse* unsafe_arena_release_regenerate_response();

  // .ai.inworld.packets.ApplyResponse apply_response = 3;
  bool has_apply_response() const;
  private:
  bool _internal_has_apply_response() const;
  public:
  void clear_apply_response();
  const ::ai::inworld::packets::ApplyResponse& apply_response() const;
  ::ai::inworld::packets::ApplyResponse* release_apply_response();
  ::ai::inworld::packets::ApplyResponse* mutable_apply_response();
  void set_allocated_apply_response(::ai::inworld::packets::ApplyResponse* apply_response);
  private:
  const ::ai::inworld::packets::ApplyResponse& _internal_apply_response() const;
  ::ai::inworld::packets::ApplyResponse* _internal_mutable_apply_response();
  public:
  void unsafe_arena_set_allocated_apply_response(
      ::ai::inworld::packets::ApplyResponse* apply_response);
  ::ai::inworld::packets::ApplyResponse* unsafe_arena_release_apply_response();

  // .ai.inworld.packets.LoadScene load_scene = 4;
  bool has_load_scene() const;
  private:
  bool _internal_has_load_scene() const;
  public:
  void clear_load_scene();
  const ::ai::inworld::packets::LoadScene& load_scene() const;
  ::ai::inworld::packets::LoadScene* release_load_scene();
  ::ai::inworld::packets::LoadScene* mutable_load_scene();
  void set_allocated_load_scene(::ai::inworld::packets::LoadScene* load_scene);
  private:
  const ::ai::inworld::packets::LoadScene& _internal_load_scene() const;
  ::ai::inworld::packets::LoadScene* _internal_mutable_load_scene();
  public:
  void unsafe_arena_set_allocated_load_scene(
      ::ai::inworld::packets::LoadScene* load_scene);
  ::ai::inworld::packets::LoadScene* unsafe_arena_release_load_scene();

  // .ai.inworld.packets.ModifyExactResponse modify_exact_response = 5;
  bool has_modify_exact_response() const;
  private:
  bool _internal_has_modify_exact_response() const;
  public:
  void clear_modify_exact_response();
  const ::ai::inworld::packets::ModifyExactResponse& modify_exact_response() const;
  ::ai::inworld::packets::ModifyExactResponse* release_modify_exact_response();
  ::ai::inworld::packets::ModifyExactResponse* mutable_modify_exact_response();
  void set_allocated_modify_exact_response(::ai::inworld::packets::ModifyExactResponse* modify_exact_response);
  private:
  const ::ai::inworld::packets::ModifyExactResponse& _internal_modify_exact_response() const;
  ::ai::inworld::packets::ModifyExactResponse* _internal_mutable_modify_exact_response();
  public:
  void unsafe_arena_set_allocated_modify_exact_response(
      ::ai::inworld::packets::ModifyExactResponse* modify_exact_response);
  ::ai::inworld::packets::ModifyExactResponse* unsafe_arena_release_modify_exact_response();

  void clear_mutation();
  MutationCase mutation_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.MutationEvent)
 private:
  class _Internal;
  void set_has_cancel_responses();
  void set_has_regenerate_response();
  void set_has_apply_response();
  void set_has_load_scene();
  void set_has_modify_exact_response();

  inline bool has_mutation() const;
  inline void clear_has_mutation();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MutationUnion {
    MutationUnion() {}
    ::ai::inworld::packets::CancelResponses* cancel_responses_;
    ::ai::inworld::packets::RegenerateResponse* regenerate_response_;
    ::ai::inworld::packets::ApplyResponse* apply_response_;
    ::ai::inworld::packets::LoadScene* load_scene_;
    ::ai::inworld::packets::ModifyExactResponse* modify_exact_response_;
  } mutation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class CancelResponses PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.CancelResponses) */ {
 public:
  inline CancelResponses() : CancelResponses(nullptr) {}
  virtual ~CancelResponses();

  CancelResponses(const CancelResponses& from);
  CancelResponses(CancelResponses&& from) noexcept
    : CancelResponses() {
    *this = ::std::move(from);
  }

  inline CancelResponses& operator=(const CancelResponses& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponses& operator=(CancelResponses&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CancelResponses& default_instance();

  static inline const CancelResponses* internal_default_instance() {
    return reinterpret_cast<const CancelResponses*>(
               &_CancelResponses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CancelResponses& a, CancelResponses& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponses* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelResponses* New() const final {
    return CreateMaybeMessage<CancelResponses>(nullptr);
  }

  CancelResponses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelResponses>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CancelResponses& from);
  void MergeFrom(const CancelResponses& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelResponses* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.CancelResponses";
  }
  protected:
  explicit CancelResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtteranceIdFieldNumber = 2,
    kInteractionIdFieldNumber = 1,
  };
  // repeated string utterance_id = 2;
  int utterance_id_size() const;
  private:
  int _internal_utterance_id_size() const;
  public:
  void clear_utterance_id();
  const std::string& utterance_id(int index) const;
  std::string* mutable_utterance_id(int index);
  void set_utterance_id(int index, const std::string& value);
  void set_utterance_id(int index, std::string&& value);
  void set_utterance_id(int index, const char* value);
  void set_utterance_id(int index, const char* value, size_t size);
  std::string* add_utterance_id();
  void add_utterance_id(const std::string& value);
  void add_utterance_id(std::string&& value);
  void add_utterance_id(const char* value);
  void add_utterance_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& utterance_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_utterance_id();
  private:
  const std::string& _internal_utterance_id(int index) const;
  std::string* _internal_add_utterance_id();
  public:

  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.CancelResponses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> utterance_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class RegenerateResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.RegenerateResponse) */ {
 public:
  inline RegenerateResponse() : RegenerateResponse(nullptr) {}
  virtual ~RegenerateResponse();

  RegenerateResponse(const RegenerateResponse& from);
  RegenerateResponse(RegenerateResponse&& from) noexcept
    : RegenerateResponse() {
    *this = ::std::move(from);
  }

  inline RegenerateResponse& operator=(const RegenerateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegenerateResponse& operator=(RegenerateResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegenerateResponse& default_instance();

  static inline const RegenerateResponse* internal_default_instance() {
    return reinterpret_cast<const RegenerateResponse*>(
               &_RegenerateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RegenerateResponse& a, RegenerateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegenerateResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegenerateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegenerateResponse* New() const final {
    return CreateMaybeMessage<RegenerateResponse>(nullptr);
  }

  RegenerateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegenerateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegenerateResponse& from);
  void MergeFrom(const RegenerateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegenerateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.RegenerateResponse";
  }
  protected:
  explicit RegenerateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
  };
  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.RegenerateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class ApplyResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ApplyResponse) */ {
 public:
  inline ApplyResponse() : ApplyResponse(nullptr) {}
  virtual ~ApplyResponse();

  ApplyResponse(const ApplyResponse& from);
  ApplyResponse(ApplyResponse&& from) noexcept
    : ApplyResponse() {
    *this = ::std::move(from);
  }

  inline ApplyResponse& operator=(const ApplyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyResponse& operator=(ApplyResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ApplyResponse& default_instance();

  static inline const ApplyResponse* internal_default_instance() {
    return reinterpret_cast<const ApplyResponse*>(
               &_ApplyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ApplyResponse& a, ApplyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplyResponse* New() const final {
    return CreateMaybeMessage<ApplyResponse>(nullptr);
  }

  ApplyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplyResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ApplyResponse& from);
  void MergeFrom(const ApplyResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ApplyResponse";
  }
  protected:
  explicit ApplyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketIdFieldNumber = 1,
  };
  // .ai.inworld.packets.PacketId packet_id = 1;
  bool has_packet_id() const;
  private:
  bool _internal_has_packet_id() const;
  public:
  void clear_packet_id();
  const ::ai::inworld::packets::PacketId& packet_id() const;
  ::ai::inworld::packets::PacketId* release_packet_id();
  ::ai::inworld::packets::PacketId* mutable_packet_id();
  void set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id);
  private:
  const ::ai::inworld::packets::PacketId& _internal_packet_id() const;
  ::ai::inworld::packets::PacketId* _internal_mutable_packet_id();
  public:
  void unsafe_arena_set_allocated_packet_id(
      ::ai::inworld::packets::PacketId* packet_id);
  ::ai::inworld::packets::PacketId* unsafe_arena_release_packet_id();

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ApplyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ai::inworld::packets::PacketId* packet_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class LoadScene PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadScene) */ {
 public:
  inline LoadScene() : LoadScene(nullptr) {}
  virtual ~LoadScene();

  LoadScene(const LoadScene& from);
  LoadScene(LoadScene&& from) noexcept
    : LoadScene() {
    *this = ::std::move(from);
  }

  inline LoadScene& operator=(const LoadScene& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadScene& operator=(LoadScene&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadScene& default_instance();

  static inline const LoadScene* internal_default_instance() {
    return reinterpret_cast<const LoadScene*>(
               &_LoadScene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LoadScene& a, LoadScene& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadScene* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadScene* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadScene* New() const final {
    return CreateMaybeMessage<LoadScene>(nullptr);
  }

  LoadScene* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadScene>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadScene& from);
  void MergeFrom(const LoadScene& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadScene* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadScene";
  }
  protected:
  explicit LoadScene(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadScene)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class ModifyExactResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.ModifyExactResponse) */ {
 public:
  inline ModifyExactResponse() : ModifyExactResponse(nullptr) {}
  virtual ~ModifyExactResponse();

  ModifyExactResponse(const ModifyExactResponse& from);
  ModifyExactResponse(ModifyExactResponse&& from) noexcept
    : ModifyExactResponse() {
    *this = ::std::move(from);
  }

  inline ModifyExactResponse& operator=(const ModifyExactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyExactResponse& operator=(ModifyExactResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModifyExactResponse& default_instance();

  static inline const ModifyExactResponse* internal_default_instance() {
    return reinterpret_cast<const ModifyExactResponse*>(
               &_ModifyExactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ModifyExactResponse& a, ModifyExactResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyExactResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyExactResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModifyExactResponse* New() const final {
    return CreateMaybeMessage<ModifyExactResponse>(nullptr);
  }

  ModifyExactResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModifyExactResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModifyExactResponse& from);
  void MergeFrom(const ModifyExactResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyExactResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.ModifyExactResponse";
  }
  protected:
  explicit ModifyExactResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInteractionIdFieldNumber = 1,
    kExactTextFieldNumber = 2,
  };
  // string interaction_id = 1;
  void clear_interaction_id();
  const std::string& interaction_id() const;
  void set_interaction_id(const std::string& value);
  void set_interaction_id(std::string&& value);
  void set_interaction_id(const char* value);
  void set_interaction_id(const char* value, size_t size);
  std::string* mutable_interaction_id();
  std::string* release_interaction_id();
  void set_allocated_interaction_id(std::string* interaction_id);
  private:
  const std::string& _internal_interaction_id() const;
  void _internal_set_interaction_id(const std::string& value);
  std::string* _internal_mutable_interaction_id();
  public:

  // string exact_text = 2;
  void clear_exact_text();
  const std::string& exact_text() const;
  void set_exact_text(const std::string& value);
  void set_exact_text(std::string&& value);
  void set_exact_text(const char* value);
  void set_exact_text(const char* value, size_t size);
  std::string* mutable_exact_text();
  std::string* release_exact_text();
  void set_allocated_exact_text(std::string* exact_text);
  private:
  const std::string& _internal_exact_text() const;
  void _internal_set_exact_text(const std::string& value);
  std::string* _internal_mutable_exact_text();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.ModifyExactResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interaction_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exact_text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class LoadSceneOutputEvent_Agent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadSceneOutputEvent.Agent) */ {
 public:
  inline LoadSceneOutputEvent_Agent() : LoadSceneOutputEvent_Agent(nullptr) {}
  virtual ~LoadSceneOutputEvent_Agent();

  LoadSceneOutputEvent_Agent(const LoadSceneOutputEvent_Agent& from);
  LoadSceneOutputEvent_Agent(LoadSceneOutputEvent_Agent&& from) noexcept
    : LoadSceneOutputEvent_Agent() {
    *this = ::std::move(from);
  }

  inline LoadSceneOutputEvent_Agent& operator=(const LoadSceneOutputEvent_Agent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadSceneOutputEvent_Agent& operator=(LoadSceneOutputEvent_Agent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadSceneOutputEvent_Agent& default_instance();

  static inline const LoadSceneOutputEvent_Agent* internal_default_instance() {
    return reinterpret_cast<const LoadSceneOutputEvent_Agent*>(
               &_LoadSceneOutputEvent_Agent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LoadSceneOutputEvent_Agent& a, LoadSceneOutputEvent_Agent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadSceneOutputEvent_Agent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadSceneOutputEvent_Agent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadSceneOutputEvent_Agent* New() const final {
    return CreateMaybeMessage<LoadSceneOutputEvent_Agent>(nullptr);
  }

  LoadSceneOutputEvent_Agent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadSceneOutputEvent_Agent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadSceneOutputEvent_Agent& from);
  void MergeFrom(const LoadSceneOutputEvent_Agent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadSceneOutputEvent_Agent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadSceneOutputEvent.Agent";
  }
  protected:
  explicit LoadSceneOutputEvent_Agent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentIdFieldNumber = 1,
    kBrainNameFieldNumber = 2,
    kGivenNameFieldNumber = 3,
  };
  // string agent_id = 1;
  void clear_agent_id();
  const std::string& agent_id() const;
  void set_agent_id(const std::string& value);
  void set_agent_id(std::string&& value);
  void set_agent_id(const char* value);
  void set_agent_id(const char* value, size_t size);
  std::string* mutable_agent_id();
  std::string* release_agent_id();
  void set_allocated_agent_id(std::string* agent_id);
  private:
  const std::string& _internal_agent_id() const;
  void _internal_set_agent_id(const std::string& value);
  std::string* _internal_mutable_agent_id();
  public:

  // string brain_name = 2;
  void clear_brain_name();
  const std::string& brain_name() const;
  void set_brain_name(const std::string& value);
  void set_brain_name(std::string&& value);
  void set_brain_name(const char* value);
  void set_brain_name(const char* value, size_t size);
  std::string* mutable_brain_name();
  std::string* release_brain_name();
  void set_allocated_brain_name(std::string* brain_name);
  private:
  const std::string& _internal_brain_name() const;
  void _internal_set_brain_name(const std::string& value);
  std::string* _internal_mutable_brain_name();
  public:

  // string given_name = 3;
  void clear_given_name();
  const std::string& given_name() const;
  void set_given_name(const std::string& value);
  void set_given_name(std::string&& value);
  void set_given_name(const char* value);
  void set_given_name(const char* value, size_t size);
  std::string* mutable_given_name();
  std::string* release_given_name();
  void set_allocated_given_name(std::string* given_name);
  private:
  const std::string& _internal_given_name() const;
  void _internal_set_given_name(const std::string& value);
  std::string* _internal_mutable_given_name();
  public:

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadSceneOutputEvent.Agent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brain_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr given_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class LoadSceneOutputEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.LoadSceneOutputEvent) */ {
 public:
  inline LoadSceneOutputEvent() : LoadSceneOutputEvent(nullptr) {}
  virtual ~LoadSceneOutputEvent();

  LoadSceneOutputEvent(const LoadSceneOutputEvent& from);
  LoadSceneOutputEvent(LoadSceneOutputEvent&& from) noexcept
    : LoadSceneOutputEvent() {
    *this = ::std::move(from);
  }

  inline LoadSceneOutputEvent& operator=(const LoadSceneOutputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadSceneOutputEvent& operator=(LoadSceneOutputEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadSceneOutputEvent& default_instance();

  static inline const LoadSceneOutputEvent* internal_default_instance() {
    return reinterpret_cast<const LoadSceneOutputEvent*>(
               &_LoadSceneOutputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(LoadSceneOutputEvent& a, LoadSceneOutputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadSceneOutputEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadSceneOutputEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadSceneOutputEvent* New() const final {
    return CreateMaybeMessage<LoadSceneOutputEvent>(nullptr);
  }

  LoadSceneOutputEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadSceneOutputEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadSceneOutputEvent& from);
  void MergeFrom(const LoadSceneOutputEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadSceneOutputEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.LoadSceneOutputEvent";
  }
  protected:
  explicit LoadSceneOutputEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LoadSceneOutputEvent_Agent Agent;

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 1,
  };
  // repeated .ai.inworld.packets.LoadSceneOutputEvent.Agent agents = 1;
  int agents_size() const;
  private:
  int _internal_agents_size() const;
  public:
  void clear_agents();
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* mutable_agents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >*
      mutable_agents();
  private:
  const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& _internal_agents(int index) const;
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* _internal_add_agents();
  public:
  const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& agents(int index) const;
  ::ai::inworld::packets::LoadSceneOutputEvent_Agent* add_agents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >&
      agents() const;

  // @@protoc_insertion_point(class_scope:ai.inworld.packets.LoadSceneOutputEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent > agents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_packets_2eproto;
};
// -------------------------------------------------------------------

class DebugInfoEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ai.inworld.packets.DebugInfoEvent) */ {
 public:
  inline DebugInfoEvent() : DebugInfoEvent(nullptr) {}
  virtual ~DebugInfoEvent();

  DebugInfoEvent(const DebugInfoEvent& from);
  DebugInfoEvent(DebugInfoEvent&& from) noexcept
    : DebugInfoEvent() {
    *this = ::std::move(from);
  }

  inline DebugInfoEvent& operator=(const DebugInfoEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugInfoEvent& operator=(DebugInfoEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugInfoEvent& default_instance();

  enum InfoCase {
    kRelation = 1,
    INFO_NOT_SET = 0,
  };

  static inline const DebugInfoEvent* internal_default_instance() {
    return reinterpret_cast<const DebugInfoEvent*>(
               &_DebugInfoEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DebugInfoEvent& a, DebugInfoEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugInfoEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugInfoEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugInfoEvent* New() const final {
    return CreateMaybeMessage<DebugInfoEvent>(nullptr);
  }

  DebugInfoEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugInfoEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugInfoEvent& from);
  void MergeFrom(const DebugInfoEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugInfoEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ai.inworld.packets.DebugInfoEvent";
  }
  protected:
  explicit DebugInfoEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_packets_2eproto);
    return ::descriptor_table_packets_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelationFieldNumber = 1,
  };
  // .ai.inworld.packets.RelationInfo relation = 1;
  bool has_relation() const;
  private:
  bool _internal_has_relation() const;
  public:
  void clear_relation();
  const ::ai::inworld::packets::RelationInfo& relation() const;
  ::ai::inworld::packets::RelationInfo* release_relation();
  ::ai::inworld::packets::RelationInfo* mutable_relation();
  void set_allocated_relation(::ai::inworld::packets::RelationInfo* relation);
  private:
  const ::ai::inworld::packets::RelationInfo& _internal_relation() const;
  ::ai::inworld::packets::RelationInfo* _internal_mutable_relation();
  public:
  void unsafe_arena_set_allocated_relation(
      ::ai::inworld::packets::RelationInfo* relation);
  ::ai::inworld::packets::RelationInfo* unsafe_arena_release_relation();

  void clear_info();
  InfoCase info_case() const;
  // @@protoc_insertion_point(class_scope:ai.inworld.packets.DebugInfoEvent)
 private:
  class _Internal;
  void set_has_relation();

  inline bool has_info() const;
  inline void clear_has_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InfoUnion {
    InfoUnion() {}
    ::ai::inworld::packets::RelationInfo* relation_;
  } info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_packets_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Actor

// .ai.inworld.packets.Actor.Type type = 1;
inline void Actor::clear_type() {
  type_ = 0;
}
inline ::ai::inworld::packets::Actor_Type Actor::_internal_type() const {
  return static_cast< ::ai::inworld::packets::Actor_Type >(type_);
}
inline ::ai::inworld::packets::Actor_Type Actor::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Actor.type)
  return _internal_type();
}
inline void Actor::_internal_set_type(::ai::inworld::packets::Actor_Type value) {
  
  type_ = value;
}
inline void Actor::set_type(::ai::inworld::packets::Actor_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Actor.type)
}

// string name = 2;
inline void Actor::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Actor::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Actor.name)
  return _internal_name();
}
inline void Actor::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.Actor.name)
}
inline std::string* Actor::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Actor.name)
  return _internal_mutable_name();
}
inline const std::string& Actor::_internal_name() const {
  return name_.Get();
}
inline void Actor::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Actor::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.Actor.name)
}
inline void Actor::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.Actor.name)
}
inline void Actor::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.Actor.name)
}
inline std::string* Actor::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Actor::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Actor.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Actor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Actor.name)
}

// -------------------------------------------------------------------

// Routing

// .ai.inworld.packets.Actor source = 1;
inline bool Routing::_internal_has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline bool Routing::has_source() const {
  return _internal_has_source();
}
inline void Routing::clear_source() {
  if (GetArena() == nullptr && source_ != nullptr) {
    delete source_;
  }
  source_ = nullptr;
}
inline const ::ai::inworld::packets::Actor& Routing::_internal_source() const {
  const ::ai::inworld::packets::Actor* p = source_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(
      ::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Routing::source() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.source)
  return _internal_source();
}
inline void Routing::unsafe_arena_set_allocated_source(
    ::ai::inworld::packets::Actor* source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Routing.source)
}
inline ::ai::inworld::packets::Actor* Routing::release_source() {
  
  ::ai::inworld::packets::Actor* temp = source_;
  source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Routing.source)
  
  ::ai::inworld::packets::Actor* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::_internal_mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArena());
    source_ = p;
  }
  return source_;
}
inline ::ai::inworld::packets::Actor* Routing::mutable_source() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.source)
  return _internal_mutable_source();
}
inline void Routing::set_allocated_source(::ai::inworld::packets::Actor* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Routing.source)
}

// .ai.inworld.packets.Actor target = 2;
inline bool Routing::_internal_has_target() const {
  return this != internal_default_instance() && target_ != nullptr;
}
inline bool Routing::has_target() const {
  return _internal_has_target();
}
inline void Routing::clear_target() {
  if (GetArena() == nullptr && target_ != nullptr) {
    delete target_;
  }
  target_ = nullptr;
}
inline const ::ai::inworld::packets::Actor& Routing::_internal_target() const {
  const ::ai::inworld::packets::Actor* p = target_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Actor&>(
      ::ai::inworld::packets::_Actor_default_instance_);
}
inline const ::ai::inworld::packets::Actor& Routing::target() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.Routing.target)
  return _internal_target();
}
inline void Routing::unsafe_arena_set_allocated_target(
    ::ai::inworld::packets::Actor* target) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_);
  }
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.Routing.target)
}
inline ::ai::inworld::packets::Actor* Routing::release_target() {
  
  ::ai::inworld::packets::Actor* temp = target_;
  target_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.Routing.target)
  
  ::ai::inworld::packets::Actor* temp = target_;
  target_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Actor* Routing::_internal_mutable_target() {
  
  if (target_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Actor>(GetArena());
    target_ = p;
  }
  return target_;
}
inline ::ai::inworld::packets::Actor* Routing::mutable_target() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.Routing.target)
  return _internal_mutable_target();
}
inline void Routing::set_allocated_target(::ai::inworld::packets::Actor* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.Routing.target)
}

// -------------------------------------------------------------------

// PacketId

// string packet_id = 1;
inline void PacketId::clear_packet_id() {
  packet_id_.ClearToEmpty();
}
inline const std::string& PacketId::packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.packet_id)
  return _internal_packet_id();
}
inline void PacketId::set_packet_id(const std::string& value) {
  _internal_set_packet_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.packet_id)
}
inline std::string* PacketId::mutable_packet_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.packet_id)
  return _internal_mutable_packet_id();
}
inline const std::string& PacketId::_internal_packet_id() const {
  return packet_id_.Get();
}
inline void PacketId::_internal_set_packet_id(const std::string& value) {
  
  packet_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PacketId::set_packet_id(std::string&& value) {
  
  packet_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.PacketId.packet_id)
}
inline void PacketId::set_packet_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  packet_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.PacketId.packet_id)
}
inline void PacketId::set_packet_id(const char* value,
    size_t size) {
  
  packet_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.PacketId.packet_id)
}
inline std::string* PacketId::_internal_mutable_packet_id() {
  
  return packet_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PacketId::release_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.packet_id)
  return packet_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PacketId::set_allocated_packet_id(std::string* packet_id) {
  if (packet_id != nullptr) {
    
  } else {
    
  }
  packet_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), packet_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.packet_id)
}

// string utterance_id = 2;
inline void PacketId::clear_utterance_id() {
  utterance_id_.ClearToEmpty();
}
inline const std::string& PacketId::utterance_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.utterance_id)
  return _internal_utterance_id();
}
inline void PacketId::set_utterance_id(const std::string& value) {
  _internal_set_utterance_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.utterance_id)
}
inline std::string* PacketId::mutable_utterance_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.utterance_id)
  return _internal_mutable_utterance_id();
}
inline const std::string& PacketId::_internal_utterance_id() const {
  return utterance_id_.Get();
}
inline void PacketId::_internal_set_utterance_id(const std::string& value) {
  
  utterance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PacketId::set_utterance_id(std::string&& value) {
  
  utterance_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.PacketId.utterance_id)
}
inline void PacketId::set_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  utterance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.PacketId.utterance_id)
}
inline void PacketId::set_utterance_id(const char* value,
    size_t size) {
  
  utterance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.PacketId.utterance_id)
}
inline std::string* PacketId::_internal_mutable_utterance_id() {
  
  return utterance_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PacketId::release_utterance_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.utterance_id)
  return utterance_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PacketId::set_allocated_utterance_id(std::string* utterance_id) {
  if (utterance_id != nullptr) {
    
  } else {
    
  }
  utterance_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), utterance_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.utterance_id)
}

// string interaction_id = 3;
inline void PacketId::clear_interaction_id() {
  interaction_id_.ClearToEmpty();
}
inline const std::string& PacketId::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.interaction_id)
  return _internal_interaction_id();
}
inline void PacketId::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.interaction_id)
}
inline std::string* PacketId::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& PacketId::_internal_interaction_id() const {
  return interaction_id_.Get();
}
inline void PacketId::_internal_set_interaction_id(const std::string& value) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PacketId::set_interaction_id(std::string&& value) {
  
  interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.PacketId.interaction_id)
}
inline void PacketId::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.PacketId.interaction_id)
}
inline void PacketId::set_interaction_id(const char* value,
    size_t size) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.PacketId.interaction_id)
}
inline std::string* PacketId::_internal_mutable_interaction_id() {
  
  return interaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PacketId::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.interaction_id)
  return interaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PacketId::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  interaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.interaction_id)
}

// string correlation_id = 4;
inline void PacketId::clear_correlation_id() {
  correlation_id_.ClearToEmpty();
}
inline const std::string& PacketId::correlation_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.PacketId.correlation_id)
  return _internal_correlation_id();
}
inline void PacketId::set_correlation_id(const std::string& value) {
  _internal_set_correlation_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.PacketId.correlation_id)
}
inline std::string* PacketId::mutable_correlation_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.PacketId.correlation_id)
  return _internal_mutable_correlation_id();
}
inline const std::string& PacketId::_internal_correlation_id() const {
  return correlation_id_.Get();
}
inline void PacketId::_internal_set_correlation_id(const std::string& value) {
  
  correlation_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PacketId::set_correlation_id(std::string&& value) {
  
  correlation_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.PacketId.correlation_id)
}
inline void PacketId::set_correlation_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  correlation_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.PacketId.correlation_id)
}
inline void PacketId::set_correlation_id(const char* value,
    size_t size) {
  
  correlation_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.PacketId.correlation_id)
}
inline std::string* PacketId::_internal_mutable_correlation_id() {
  
  return correlation_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PacketId::release_correlation_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.PacketId.correlation_id)
  return correlation_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PacketId::set_allocated_correlation_id(std::string* correlation_id) {
  if (correlation_id != nullptr) {
    
  } else {
    
  }
  correlation_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), correlation_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.PacketId.correlation_id)
}

// -------------------------------------------------------------------

// InworldPacket

// .google.protobuf.Timestamp timestamp = 1;
inline bool InworldPacket::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool InworldPacket::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& InworldPacket::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& InworldPacket::timestamp() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.timestamp)
  return _internal_timestamp();
}
inline void InworldPacket::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* InworldPacket::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.timestamp)
  return _internal_mutable_timestamp();
}
inline void InworldPacket::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.timestamp)
}

// .ai.inworld.packets.Routing routing = 6;
inline bool InworldPacket::_internal_has_routing() const {
  return this != internal_default_instance() && routing_ != nullptr;
}
inline bool InworldPacket::has_routing() const {
  return _internal_has_routing();
}
inline void InworldPacket::clear_routing() {
  if (GetArena() == nullptr && routing_ != nullptr) {
    delete routing_;
  }
  routing_ = nullptr;
}
inline const ::ai::inworld::packets::Routing& InworldPacket::_internal_routing() const {
  const ::ai::inworld::packets::Routing* p = routing_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::Routing&>(
      ::ai::inworld::packets::_Routing_default_instance_);
}
inline const ::ai::inworld::packets::Routing& InworldPacket::routing() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.routing)
  return _internal_routing();
}
inline void InworldPacket::unsafe_arena_set_allocated_routing(
    ::ai::inworld::packets::Routing* routing) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routing_);
  }
  routing_ = routing;
  if (routing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.routing)
}
inline ::ai::inworld::packets::Routing* InworldPacket::release_routing() {
  
  ::ai::inworld::packets::Routing* temp = routing_;
  routing_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::Routing* InworldPacket::unsafe_arena_release_routing() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.routing)
  
  ::ai::inworld::packets::Routing* temp = routing_;
  routing_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::Routing* InworldPacket::_internal_mutable_routing() {
  
  if (routing_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::Routing>(GetArena());
    routing_ = p;
  }
  return routing_;
}
inline ::ai::inworld::packets::Routing* InworldPacket::mutable_routing() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.routing)
  return _internal_mutable_routing();
}
inline void InworldPacket::set_allocated_routing(::ai::inworld::packets::Routing* routing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete routing_;
  }
  if (routing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(routing);
    if (message_arena != submessage_arena) {
      routing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routing, submessage_arena);
    }
    
  } else {
    
  }
  routing_ = routing;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.routing)
}

// .ai.inworld.packets.PacketId packet_id = 9;
inline bool InworldPacket::_internal_has_packet_id() const {
  return this != internal_default_instance() && packet_id_ != nullptr;
}
inline bool InworldPacket::has_packet_id() const {
  return _internal_has_packet_id();
}
inline void InworldPacket::clear_packet_id() {
  if (GetArena() == nullptr && packet_id_ != nullptr) {
    delete packet_id_;
  }
  packet_id_ = nullptr;
}
inline const ::ai::inworld::packets::PacketId& InworldPacket::_internal_packet_id() const {
  const ::ai::inworld::packets::PacketId* p = packet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::PacketId&>(
      ::ai::inworld::packets::_PacketId_default_instance_);
}
inline const ::ai::inworld::packets::PacketId& InworldPacket::packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.packet_id)
  return _internal_packet_id();
}
inline void InworldPacket::unsafe_arena_set_allocated_packet_id(
    ::ai::inworld::packets::PacketId* packet_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet_id_);
  }
  packet_id_ = packet_id;
  if (packet_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.packet_id)
}
inline ::ai::inworld::packets::PacketId* InworldPacket::release_packet_id() {
  
  ::ai::inworld::packets::PacketId* temp = packet_id_;
  packet_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::unsafe_arena_release_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.packet_id)
  
  ::ai::inworld::packets::PacketId* temp = packet_id_;
  packet_id_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::_internal_mutable_packet_id() {
  
  if (packet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::PacketId>(GetArena());
    packet_id_ = p;
  }
  return packet_id_;
}
inline ::ai::inworld::packets::PacketId* InworldPacket::mutable_packet_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.packet_id)
  return _internal_mutable_packet_id();
}
inline void InworldPacket::set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete packet_id_;
  }
  if (packet_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(packet_id);
    if (message_arena != submessage_arena) {
      packet_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_id, submessage_arena);
    }
    
  } else {
    
  }
  packet_id_ = packet_id;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.InworldPacket.packet_id)
}

// .ai.inworld.packets.TextEvent text = 2;
inline bool InworldPacket::_internal_has_text() const {
  return packet_case() == kText;
}
inline bool InworldPacket::has_text() const {
  return _internal_has_text();
}
inline void InworldPacket::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void InworldPacket::clear_text() {
  if (_internal_has_text()) {
    if (GetArena() == nullptr) {
      delete packet_.text_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.text)
  if (_internal_has_text()) {
    clear_has_packet();
      ::ai::inworld::packets::TextEvent* temp = packet_.text_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::TextEvent& InworldPacket::_internal_text() const {
  return _internal_has_text()
      ? *packet_.text_
      : reinterpret_cast< ::ai::inworld::packets::TextEvent&>(::ai::inworld::packets::_TextEvent_default_instance_);
}
inline const ::ai::inworld::packets::TextEvent& InworldPacket::text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.text)
  return _internal_text();
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.text)
  if (_internal_has_text()) {
    clear_has_packet();
    ::ai::inworld::packets::TextEvent* temp = packet_.text_;
    packet_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_text(::ai::inworld::packets::TextEvent* text) {
  clear_packet();
  if (text) {
    set_has_text();
    packet_.text_ = text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.text)
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_packet();
    set_has_text();
    packet_.text_ = CreateMaybeMessage< ::ai::inworld::packets::TextEvent >(GetArena());
  }
  return packet_.text_;
}
inline ::ai::inworld::packets::TextEvent* InworldPacket::mutable_text() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.text)
  return _internal_mutable_text();
}

// .ai.inworld.packets.ControlEvent control = 3;
inline bool InworldPacket::_internal_has_control() const {
  return packet_case() == kControl;
}
inline bool InworldPacket::has_control() const {
  return _internal_has_control();
}
inline void InworldPacket::set_has_control() {
  _oneof_case_[0] = kControl;
}
inline void InworldPacket::clear_control() {
  if (_internal_has_control()) {
    if (GetArena() == nullptr) {
      delete packet_.control_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::release_control() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.control)
  if (_internal_has_control()) {
    clear_has_packet();
      ::ai::inworld::packets::ControlEvent* temp = packet_.control_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ControlEvent& InworldPacket::_internal_control() const {
  return _internal_has_control()
      ? *packet_.control_
      : reinterpret_cast< ::ai::inworld::packets::ControlEvent&>(::ai::inworld::packets::_ControlEvent_default_instance_);
}
inline const ::ai::inworld::packets::ControlEvent& InworldPacket::control() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.control)
  return _internal_control();
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.control)
  if (_internal_has_control()) {
    clear_has_packet();
    ::ai::inworld::packets::ControlEvent* temp = packet_.control_;
    packet_.control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_control(::ai::inworld::packets::ControlEvent* control) {
  clear_packet();
  if (control) {
    set_has_control();
    packet_.control_ = control;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.control)
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::_internal_mutable_control() {
  if (!_internal_has_control()) {
    clear_packet();
    set_has_control();
    packet_.control_ = CreateMaybeMessage< ::ai::inworld::packets::ControlEvent >(GetArena());
  }
  return packet_.control_;
}
inline ::ai::inworld::packets::ControlEvent* InworldPacket::mutable_control() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.control)
  return _internal_mutable_control();
}

// .ai.inworld.packets.AudioChunk audio_chunk = 4 [deprecated = true];
inline bool InworldPacket::_internal_has_audio_chunk() const {
  return packet_case() == kAudioChunk;
}
inline bool InworldPacket::has_audio_chunk() const {
  return _internal_has_audio_chunk();
}
inline void InworldPacket::set_has_audio_chunk() {
  _oneof_case_[0] = kAudioChunk;
}
inline void InworldPacket::clear_audio_chunk() {
  if (_internal_has_audio_chunk()) {
    if (GetArena() == nullptr) {
      delete packet_.audio_chunk_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::release_audio_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.audio_chunk)
  if (_internal_has_audio_chunk()) {
    clear_has_packet();
      ::ai::inworld::packets::AudioChunk* temp = packet_.audio_chunk_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.audio_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::AudioChunk& InworldPacket::_internal_audio_chunk() const {
  return _internal_has_audio_chunk()
      ? *packet_.audio_chunk_
      : reinterpret_cast< ::ai::inworld::packets::AudioChunk&>(::ai::inworld::packets::_AudioChunk_default_instance_);
}
inline const ::ai::inworld::packets::AudioChunk& InworldPacket::audio_chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.audio_chunk)
  return _internal_audio_chunk();
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::unsafe_arena_release_audio_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.audio_chunk)
  if (_internal_has_audio_chunk()) {
    clear_has_packet();
    ::ai::inworld::packets::AudioChunk* temp = packet_.audio_chunk_;
    packet_.audio_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_audio_chunk(::ai::inworld::packets::AudioChunk* audio_chunk) {
  clear_packet();
  if (audio_chunk) {
    set_has_audio_chunk();
    packet_.audio_chunk_ = audio_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.audio_chunk)
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::_internal_mutable_audio_chunk() {
  if (!_internal_has_audio_chunk()) {
    clear_packet();
    set_has_audio_chunk();
    packet_.audio_chunk_ = CreateMaybeMessage< ::ai::inworld::packets::AudioChunk >(GetArena());
  }
  return packet_.audio_chunk_;
}
inline ::ai::inworld::packets::AudioChunk* InworldPacket::mutable_audio_chunk() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.audio_chunk)
  return _internal_mutable_audio_chunk();
}

// .ai.inworld.packets.CustomEvent custom = 8;
inline bool InworldPacket::_internal_has_custom() const {
  return packet_case() == kCustom;
}
inline bool InworldPacket::has_custom() const {
  return _internal_has_custom();
}
inline void InworldPacket::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void InworldPacket::clear_custom() {
  if (_internal_has_custom()) {
    if (GetArena() == nullptr) {
      delete packet_.custom_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::release_custom() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.custom)
  if (_internal_has_custom()) {
    clear_has_packet();
      ::ai::inworld::packets::CustomEvent* temp = packet_.custom_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CustomEvent& InworldPacket::_internal_custom() const {
  return _internal_has_custom()
      ? *packet_.custom_
      : reinterpret_cast< ::ai::inworld::packets::CustomEvent&>(::ai::inworld::packets::_CustomEvent_default_instance_);
}
inline const ::ai::inworld::packets::CustomEvent& InworldPacket::custom() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.custom)
  return _internal_custom();
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.custom)
  if (_internal_has_custom()) {
    clear_has_packet();
    ::ai::inworld::packets::CustomEvent* temp = packet_.custom_;
    packet_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_custom(::ai::inworld::packets::CustomEvent* custom) {
  clear_packet();
  if (custom) {
    set_has_custom();
    packet_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.custom)
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::_internal_mutable_custom() {
  if (!_internal_has_custom()) {
    clear_packet();
    set_has_custom();
    packet_.custom_ = CreateMaybeMessage< ::ai::inworld::packets::CustomEvent >(GetArena());
  }
  return packet_.custom_;
}
inline ::ai::inworld::packets::CustomEvent* InworldPacket::mutable_custom() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.custom)
  return _internal_mutable_custom();
}

// .ai.inworld.packets.CancelResponsesEvent cancelResponses = 10 [deprecated = true];
inline bool InworldPacket::_internal_has_cancelresponses() const {
  return packet_case() == kCancelResponses;
}
inline bool InworldPacket::has_cancelresponses() const {
  return _internal_has_cancelresponses();
}
inline void InworldPacket::set_has_cancelresponses() {
  _oneof_case_[0] = kCancelResponses;
}
inline void InworldPacket::clear_cancelresponses() {
  if (_internal_has_cancelresponses()) {
    if (GetArena() == nullptr) {
      delete packet_.cancelresponses_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::release_cancelresponses() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.cancelResponses)
  if (_internal_has_cancelresponses()) {
    clear_has_packet();
      ::ai::inworld::packets::CancelResponsesEvent* temp = packet_.cancelresponses_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.cancelresponses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CancelResponsesEvent& InworldPacket::_internal_cancelresponses() const {
  return _internal_has_cancelresponses()
      ? *packet_.cancelresponses_
      : reinterpret_cast< ::ai::inworld::packets::CancelResponsesEvent&>(::ai::inworld::packets::_CancelResponsesEvent_default_instance_);
}
inline const ::ai::inworld::packets::CancelResponsesEvent& InworldPacket::cancelresponses() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.cancelResponses)
  return _internal_cancelresponses();
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::unsafe_arena_release_cancelresponses() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.cancelResponses)
  if (_internal_has_cancelresponses()) {
    clear_has_packet();
    ::ai::inworld::packets::CancelResponsesEvent* temp = packet_.cancelresponses_;
    packet_.cancelresponses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_cancelresponses(::ai::inworld::packets::CancelResponsesEvent* cancelresponses) {
  clear_packet();
  if (cancelresponses) {
    set_has_cancelresponses();
    packet_.cancelresponses_ = cancelresponses;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.cancelResponses)
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::_internal_mutable_cancelresponses() {
  if (!_internal_has_cancelresponses()) {
    clear_packet();
    set_has_cancelresponses();
    packet_.cancelresponses_ = CreateMaybeMessage< ::ai::inworld::packets::CancelResponsesEvent >(GetArena());
  }
  return packet_.cancelresponses_;
}
inline ::ai::inworld::packets::CancelResponsesEvent* InworldPacket::mutable_cancelresponses() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.cancelResponses)
  return _internal_mutable_cancelresponses();
}

// .ai.inworld.packets.EmotionEvent emotion = 11;
inline bool InworldPacket::_internal_has_emotion() const {
  return packet_case() == kEmotion;
}
inline bool InworldPacket::has_emotion() const {
  return _internal_has_emotion();
}
inline void InworldPacket::set_has_emotion() {
  _oneof_case_[0] = kEmotion;
}
inline void InworldPacket::clear_emotion() {
  if (_internal_has_emotion()) {
    if (GetArena() == nullptr) {
      delete packet_.emotion_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::release_emotion() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.emotion)
  if (_internal_has_emotion()) {
    clear_has_packet();
      ::ai::inworld::packets::EmotionEvent* temp = packet_.emotion_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.emotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::EmotionEvent& InworldPacket::_internal_emotion() const {
  return _internal_has_emotion()
      ? *packet_.emotion_
      : reinterpret_cast< ::ai::inworld::packets::EmotionEvent&>(::ai::inworld::packets::_EmotionEvent_default_instance_);
}
inline const ::ai::inworld::packets::EmotionEvent& InworldPacket::emotion() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.emotion)
  return _internal_emotion();
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::unsafe_arena_release_emotion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.emotion)
  if (_internal_has_emotion()) {
    clear_has_packet();
    ::ai::inworld::packets::EmotionEvent* temp = packet_.emotion_;
    packet_.emotion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_emotion(::ai::inworld::packets::EmotionEvent* emotion) {
  clear_packet();
  if (emotion) {
    set_has_emotion();
    packet_.emotion_ = emotion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.emotion)
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::_internal_mutable_emotion() {
  if (!_internal_has_emotion()) {
    clear_packet();
    set_has_emotion();
    packet_.emotion_ = CreateMaybeMessage< ::ai::inworld::packets::EmotionEvent >(GetArena());
  }
  return packet_.emotion_;
}
inline ::ai::inworld::packets::EmotionEvent* InworldPacket::mutable_emotion() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.emotion)
  return _internal_mutable_emotion();
}

// .ai.inworld.packets.DataChunk data_chunk = 12;
inline bool InworldPacket::_internal_has_data_chunk() const {
  return packet_case() == kDataChunk;
}
inline bool InworldPacket::has_data_chunk() const {
  return _internal_has_data_chunk();
}
inline void InworldPacket::set_has_data_chunk() {
  _oneof_case_[0] = kDataChunk;
}
inline void InworldPacket::clear_data_chunk() {
  if (_internal_has_data_chunk()) {
    if (GetArena() == nullptr) {
      delete packet_.data_chunk_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::release_data_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.data_chunk)
  if (_internal_has_data_chunk()) {
    clear_has_packet();
      ::ai::inworld::packets::DataChunk* temp = packet_.data_chunk_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.data_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::DataChunk& InworldPacket::_internal_data_chunk() const {
  return _internal_has_data_chunk()
      ? *packet_.data_chunk_
      : reinterpret_cast< ::ai::inworld::packets::DataChunk&>(::ai::inworld::packets::_DataChunk_default_instance_);
}
inline const ::ai::inworld::packets::DataChunk& InworldPacket::data_chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.data_chunk)
  return _internal_data_chunk();
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::unsafe_arena_release_data_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.data_chunk)
  if (_internal_has_data_chunk()) {
    clear_has_packet();
    ::ai::inworld::packets::DataChunk* temp = packet_.data_chunk_;
    packet_.data_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_data_chunk(::ai::inworld::packets::DataChunk* data_chunk) {
  clear_packet();
  if (data_chunk) {
    set_has_data_chunk();
    packet_.data_chunk_ = data_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.data_chunk)
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::_internal_mutable_data_chunk() {
  if (!_internal_has_data_chunk()) {
    clear_packet();
    set_has_data_chunk();
    packet_.data_chunk_ = CreateMaybeMessage< ::ai::inworld::packets::DataChunk >(GetArena());
  }
  return packet_.data_chunk_;
}
inline ::ai::inworld::packets::DataChunk* InworldPacket::mutable_data_chunk() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.data_chunk)
  return _internal_mutable_data_chunk();
}

// .ai.inworld.packets.ActionEvent action = 13;
inline bool InworldPacket::_internal_has_action() const {
  return packet_case() == kAction;
}
inline bool InworldPacket::has_action() const {
  return _internal_has_action();
}
inline void InworldPacket::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void InworldPacket::clear_action() {
  if (_internal_has_action()) {
    if (GetArena() == nullptr) {
      delete packet_.action_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::release_action() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.action)
  if (_internal_has_action()) {
    clear_has_packet();
      ::ai::inworld::packets::ActionEvent* temp = packet_.action_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ActionEvent& InworldPacket::_internal_action() const {
  return _internal_has_action()
      ? *packet_.action_
      : reinterpret_cast< ::ai::inworld::packets::ActionEvent&>(::ai::inworld::packets::_ActionEvent_default_instance_);
}
inline const ::ai::inworld::packets::ActionEvent& InworldPacket::action() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.action)
  return _internal_action();
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.action)
  if (_internal_has_action()) {
    clear_has_packet();
    ::ai::inworld::packets::ActionEvent* temp = packet_.action_;
    packet_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_action(::ai::inworld::packets::ActionEvent* action) {
  clear_packet();
  if (action) {
    set_has_action();
    packet_.action_ = action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.action)
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::_internal_mutable_action() {
  if (!_internal_has_action()) {
    clear_packet();
    set_has_action();
    packet_.action_ = CreateMaybeMessage< ::ai::inworld::packets::ActionEvent >(GetArena());
  }
  return packet_.action_;
}
inline ::ai::inworld::packets::ActionEvent* InworldPacket::mutable_action() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.action)
  return _internal_mutable_action();
}

// .ai.inworld.packets.MutationEvent mutation = 15;
inline bool InworldPacket::_internal_has_mutation() const {
  return packet_case() == kMutation;
}
inline bool InworldPacket::has_mutation() const {
  return _internal_has_mutation();
}
inline void InworldPacket::set_has_mutation() {
  _oneof_case_[0] = kMutation;
}
inline void InworldPacket::clear_mutation() {
  if (_internal_has_mutation()) {
    if (GetArena() == nullptr) {
      delete packet_.mutation_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::release_mutation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.mutation)
  if (_internal_has_mutation()) {
    clear_has_packet();
      ::ai::inworld::packets::MutationEvent* temp = packet_.mutation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.mutation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::MutationEvent& InworldPacket::_internal_mutation() const {
  return _internal_has_mutation()
      ? *packet_.mutation_
      : reinterpret_cast< ::ai::inworld::packets::MutationEvent&>(::ai::inworld::packets::_MutationEvent_default_instance_);
}
inline const ::ai::inworld::packets::MutationEvent& InworldPacket::mutation() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.mutation)
  return _internal_mutation();
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::unsafe_arena_release_mutation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.mutation)
  if (_internal_has_mutation()) {
    clear_has_packet();
    ::ai::inworld::packets::MutationEvent* temp = packet_.mutation_;
    packet_.mutation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_mutation(::ai::inworld::packets::MutationEvent* mutation) {
  clear_packet();
  if (mutation) {
    set_has_mutation();
    packet_.mutation_ = mutation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.mutation)
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::_internal_mutable_mutation() {
  if (!_internal_has_mutation()) {
    clear_packet();
    set_has_mutation();
    packet_.mutation_ = CreateMaybeMessage< ::ai::inworld::packets::MutationEvent >(GetArena());
  }
  return packet_.mutation_;
}
inline ::ai::inworld::packets::MutationEvent* InworldPacket::mutable_mutation() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.mutation)
  return _internal_mutable_mutation();
}

// .ai.inworld.packets.LoadSceneOutputEvent load_scene_output = 16;
inline bool InworldPacket::_internal_has_load_scene_output() const {
  return packet_case() == kLoadSceneOutput;
}
inline bool InworldPacket::has_load_scene_output() const {
  return _internal_has_load_scene_output();
}
inline void InworldPacket::set_has_load_scene_output() {
  _oneof_case_[0] = kLoadSceneOutput;
}
inline void InworldPacket::clear_load_scene_output() {
  if (_internal_has_load_scene_output()) {
    if (GetArena() == nullptr) {
      delete packet_.load_scene_output_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::release_load_scene_output() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.load_scene_output)
  if (_internal_has_load_scene_output()) {
    clear_has_packet();
      ::ai::inworld::packets::LoadSceneOutputEvent* temp = packet_.load_scene_output_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.load_scene_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent& InworldPacket::_internal_load_scene_output() const {
  return _internal_has_load_scene_output()
      ? *packet_.load_scene_output_
      : reinterpret_cast< ::ai::inworld::packets::LoadSceneOutputEvent&>(::ai::inworld::packets::_LoadSceneOutputEvent_default_instance_);
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent& InworldPacket::load_scene_output() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.load_scene_output)
  return _internal_load_scene_output();
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::unsafe_arena_release_load_scene_output() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.load_scene_output)
  if (_internal_has_load_scene_output()) {
    clear_has_packet();
    ::ai::inworld::packets::LoadSceneOutputEvent* temp = packet_.load_scene_output_;
    packet_.load_scene_output_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_load_scene_output(::ai::inworld::packets::LoadSceneOutputEvent* load_scene_output) {
  clear_packet();
  if (load_scene_output) {
    set_has_load_scene_output();
    packet_.load_scene_output_ = load_scene_output;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.load_scene_output)
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::_internal_mutable_load_scene_output() {
  if (!_internal_has_load_scene_output()) {
    clear_packet();
    set_has_load_scene_output();
    packet_.load_scene_output_ = CreateMaybeMessage< ::ai::inworld::packets::LoadSceneOutputEvent >(GetArena());
  }
  return packet_.load_scene_output_;
}
inline ::ai::inworld::packets::LoadSceneOutputEvent* InworldPacket::mutable_load_scene_output() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.load_scene_output)
  return _internal_mutable_load_scene_output();
}

// .ai.inworld.packets.DebugInfoEvent debug_info = 18;
inline bool InworldPacket::_internal_has_debug_info() const {
  return packet_case() == kDebugInfo;
}
inline bool InworldPacket::has_debug_info() const {
  return _internal_has_debug_info();
}
inline void InworldPacket::set_has_debug_info() {
  _oneof_case_[0] = kDebugInfo;
}
inline void InworldPacket::clear_debug_info() {
  if (_internal_has_debug_info()) {
    if (GetArena() == nullptr) {
      delete packet_.debug_info_;
    }
    clear_has_packet();
  }
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::release_debug_info() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.InworldPacket.debug_info)
  if (_internal_has_debug_info()) {
    clear_has_packet();
      ::ai::inworld::packets::DebugInfoEvent* temp = packet_.debug_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    packet_.debug_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::DebugInfoEvent& InworldPacket::_internal_debug_info() const {
  return _internal_has_debug_info()
      ? *packet_.debug_info_
      : reinterpret_cast< ::ai::inworld::packets::DebugInfoEvent&>(::ai::inworld::packets::_DebugInfoEvent_default_instance_);
}
inline const ::ai::inworld::packets::DebugInfoEvent& InworldPacket::debug_info() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.InworldPacket.debug_info)
  return _internal_debug_info();
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::unsafe_arena_release_debug_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.InworldPacket.debug_info)
  if (_internal_has_debug_info()) {
    clear_has_packet();
    ::ai::inworld::packets::DebugInfoEvent* temp = packet_.debug_info_;
    packet_.debug_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InworldPacket::unsafe_arena_set_allocated_debug_info(::ai::inworld::packets::DebugInfoEvent* debug_info) {
  clear_packet();
  if (debug_info) {
    set_has_debug_info();
    packet_.debug_info_ = debug_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.InworldPacket.debug_info)
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::_internal_mutable_debug_info() {
  if (!_internal_has_debug_info()) {
    clear_packet();
    set_has_debug_info();
    packet_.debug_info_ = CreateMaybeMessage< ::ai::inworld::packets::DebugInfoEvent >(GetArena());
  }
  return packet_.debug_info_;
}
inline ::ai::inworld::packets::DebugInfoEvent* InworldPacket::mutable_debug_info() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.InworldPacket.debug_info)
  return _internal_mutable_debug_info();
}

inline bool InworldPacket::has_packet() const {
  return packet_case() != PACKET_NOT_SET;
}
inline void InworldPacket::clear_has_packet() {
  _oneof_case_[0] = PACKET_NOT_SET;
}
inline InworldPacket::PacketCase InworldPacket::packet_case() const {
  return InworldPacket::PacketCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextEvent_ModelInfo

// string service = 1;
inline void TextEvent_ModelInfo::clear_service() {
  service_.ClearToEmpty();
}
inline const std::string& TextEvent_ModelInfo::service() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.ModelInfo.service)
  return _internal_service();
}
inline void TextEvent_ModelInfo::set_service(const std::string& value) {
  _internal_set_service(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.ModelInfo.service)
}
inline std::string* TextEvent_ModelInfo::mutable_service() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.ModelInfo.service)
  return _internal_mutable_service();
}
inline const std::string& TextEvent_ModelInfo::_internal_service() const {
  return service_.Get();
}
inline void TextEvent_ModelInfo::_internal_set_service(const std::string& value) {
  
  service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TextEvent_ModelInfo::set_service(std::string&& value) {
  
  service_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.TextEvent.ModelInfo.service)
}
inline void TextEvent_ModelInfo::set_service(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.TextEvent.ModelInfo.service)
}
inline void TextEvent_ModelInfo::set_service(const char* value,
    size_t size) {
  
  service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.TextEvent.ModelInfo.service)
}
inline std::string* TextEvent_ModelInfo::_internal_mutable_service() {
  
  return service_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TextEvent_ModelInfo::release_service() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.ModelInfo.service)
  return service_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextEvent_ModelInfo::set_allocated_service(std::string* service) {
  if (service != nullptr) {
    
  } else {
    
  }
  service_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.ModelInfo.service)
}

// string model = 2;
inline void TextEvent_ModelInfo::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& TextEvent_ModelInfo::model() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.ModelInfo.model)
  return _internal_model();
}
inline void TextEvent_ModelInfo::set_model(const std::string& value) {
  _internal_set_model(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.ModelInfo.model)
}
inline std::string* TextEvent_ModelInfo::mutable_model() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.ModelInfo.model)
  return _internal_mutable_model();
}
inline const std::string& TextEvent_ModelInfo::_internal_model() const {
  return model_.Get();
}
inline void TextEvent_ModelInfo::_internal_set_model(const std::string& value) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TextEvent_ModelInfo::set_model(std::string&& value) {
  
  model_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.TextEvent.ModelInfo.model)
}
inline void TextEvent_ModelInfo::set_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.TextEvent.ModelInfo.model)
}
inline void TextEvent_ModelInfo::set_model(const char* value,
    size_t size) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.TextEvent.ModelInfo.model)
}
inline std::string* TextEvent_ModelInfo::_internal_mutable_model() {
  
  return model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TextEvent_ModelInfo::release_model() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.ModelInfo.model)
  return model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextEvent_ModelInfo::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.ModelInfo.model)
}

// -------------------------------------------------------------------

// TextEvent

// string text = 1;
inline void TextEvent::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& TextEvent::text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.text)
  return _internal_text();
}
inline void TextEvent::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.text)
}
inline std::string* TextEvent::mutable_text() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.text)
  return _internal_mutable_text();
}
inline const std::string& TextEvent::_internal_text() const {
  return text_.Get();
}
inline void TextEvent::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TextEvent::set_text(std::string&& value) {
  
  text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.TextEvent.text)
}
inline void TextEvent::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.TextEvent.text)
}
inline void TextEvent::set_text(const char* value,
    size_t size) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.TextEvent.text)
}
inline std::string* TextEvent::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TextEvent::release_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextEvent::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.text)
}

// .ai.inworld.packets.TextEvent.SourceType source_type = 2;
inline void TextEvent::clear_source_type() {
  source_type_ = 0;
}
inline ::ai::inworld::packets::TextEvent_SourceType TextEvent::_internal_source_type() const {
  return static_cast< ::ai::inworld::packets::TextEvent_SourceType >(source_type_);
}
inline ::ai::inworld::packets::TextEvent_SourceType TextEvent::source_type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.source_type)
  return _internal_source_type();
}
inline void TextEvent::_internal_set_source_type(::ai::inworld::packets::TextEvent_SourceType value) {
  
  source_type_ = value;
}
inline void TextEvent::set_source_type(::ai::inworld::packets::TextEvent_SourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.source_type)
}

// bool final = 3;
inline void TextEvent::clear_final() {
  final_ = false;
}
inline bool TextEvent::_internal_final() const {
  return final_;
}
inline bool TextEvent::final() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.final)
  return _internal_final();
}
inline void TextEvent::_internal_set_final(bool value) {
  
  final_ = value;
}
inline void TextEvent::set_final(bool value) {
  _internal_set_final(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.TextEvent.final)
}

// .ai.inworld.packets.TextEvent.ModelInfo model_info = 4 [(.ai.inworld.options.field_mode) = HIDDEN];
inline bool TextEvent::_internal_has_model_info() const {
  return this != internal_default_instance() && model_info_ != nullptr;
}
inline bool TextEvent::has_model_info() const {
  return _internal_has_model_info();
}
inline void TextEvent::clear_model_info() {
  if (GetArena() == nullptr && model_info_ != nullptr) {
    delete model_info_;
  }
  model_info_ = nullptr;
}
inline const ::ai::inworld::packets::TextEvent_ModelInfo& TextEvent::_internal_model_info() const {
  const ::ai::inworld::packets::TextEvent_ModelInfo* p = model_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::TextEvent_ModelInfo&>(
      ::ai::inworld::packets::_TextEvent_ModelInfo_default_instance_);
}
inline const ::ai::inworld::packets::TextEvent_ModelInfo& TextEvent::model_info() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.TextEvent.model_info)
  return _internal_model_info();
}
inline void TextEvent::unsafe_arena_set_allocated_model_info(
    ::ai::inworld::packets::TextEvent_ModelInfo* model_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_info_);
  }
  model_info_ = model_info;
  if (model_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.TextEvent.model_info)
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::release_model_info() {
  
  ::ai::inworld::packets::TextEvent_ModelInfo* temp = model_info_;
  model_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::unsafe_arena_release_model_info() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.TextEvent.model_info)
  
  ::ai::inworld::packets::TextEvent_ModelInfo* temp = model_info_;
  model_info_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::_internal_mutable_model_info() {
  
  if (model_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::TextEvent_ModelInfo>(GetArena());
    model_info_ = p;
  }
  return model_info_;
}
inline ::ai::inworld::packets::TextEvent_ModelInfo* TextEvent::mutable_model_info() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.TextEvent.model_info)
  return _internal_mutable_model_info();
}
inline void TextEvent::set_allocated_model_info(::ai::inworld::packets::TextEvent_ModelInfo* model_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete model_info_;
  }
  if (model_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(model_info);
    if (message_arena != submessage_arena) {
      model_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_info, submessage_arena);
    }
    
  } else {
    
  }
  model_info_ = model_info;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.TextEvent.model_info)
}

// -------------------------------------------------------------------

// ControlEvent

// .ai.inworld.packets.ControlEvent.Action action = 1;
inline void ControlEvent::clear_action() {
  action_ = 0;
}
inline ::ai::inworld::packets::ControlEvent_Action ControlEvent::_internal_action() const {
  return static_cast< ::ai::inworld::packets::ControlEvent_Action >(action_);
}
inline ::ai::inworld::packets::ControlEvent_Action ControlEvent::action() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.action)
  return _internal_action();
}
inline void ControlEvent::_internal_set_action(::ai::inworld::packets::ControlEvent_Action value) {
  
  action_ = value;
}
inline void ControlEvent::set_action(::ai::inworld::packets::ControlEvent_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ControlEvent.action)
}

// string description = 2;
inline void ControlEvent::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& ControlEvent::description() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.description)
  return _internal_description();
}
inline void ControlEvent::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ControlEvent.description)
}
inline std::string* ControlEvent::mutable_description() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.description)
  return _internal_mutable_description();
}
inline const std::string& ControlEvent::_internal_description() const {
  return description_.Get();
}
inline void ControlEvent::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ControlEvent::set_description(std::string&& value) {
  
  description_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.ControlEvent.description)
}
inline void ControlEvent::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.ControlEvent.description)
}
inline void ControlEvent::set_description(const char* value,
    size_t size) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.ControlEvent.description)
}
inline std::string* ControlEvent::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ControlEvent::release_description() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControlEvent::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ControlEvent.description)
}

// .google.protobuf.Struct payload = 3;
inline bool ControlEvent::_internal_has_payload() const {
  return this != internal_default_instance() && payload_ != nullptr;
}
inline bool ControlEvent::has_payload() const {
  return _internal_has_payload();
}
inline const PROTOBUF_NAMESPACE_ID::Struct& ControlEvent::_internal_payload() const {
  const PROTOBUF_NAMESPACE_ID::Struct* p = payload_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Struct&>(
      PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Struct& ControlEvent::payload() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ControlEvent.payload)
  return _internal_payload();
}
inline void ControlEvent::unsafe_arena_set_allocated_payload(
    PROTOBUF_NAMESPACE_ID::Struct* payload) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  payload_ = payload;
  if (payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ControlEvent.payload)
}
inline PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::release_payload() {
  
  PROTOBUF_NAMESPACE_ID::Struct* temp = payload_;
  payload_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ControlEvent.payload)
  
  PROTOBUF_NAMESPACE_ID::Struct* temp = payload_;
  payload_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::_internal_mutable_payload() {
  
  if (payload_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Struct>(GetArena());
    payload_ = p;
  }
  return payload_;
}
inline PROTOBUF_NAMESPACE_ID::Struct* ControlEvent::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ControlEvent.payload)
  return _internal_mutable_payload();
}
inline void ControlEvent::set_allocated_payload(PROTOBUF_NAMESPACE_ID::Struct* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_);
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload)->GetArena();
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    
  } else {
    
  }
  payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ControlEvent.payload)
}

// -------------------------------------------------------------------

// AudioChunk

// bytes chunk = 1;
inline void AudioChunk::clear_chunk() {
  chunk_.ClearToEmpty();
}
inline const std::string& AudioChunk::chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AudioChunk.chunk)
  return _internal_chunk();
}
inline void AudioChunk::set_chunk(const std::string& value) {
  _internal_set_chunk(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.AudioChunk.chunk)
}
inline std::string* AudioChunk::mutable_chunk() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AudioChunk.chunk)
  return _internal_mutable_chunk();
}
inline const std::string& AudioChunk::_internal_chunk() const {
  return chunk_.Get();
}
inline void AudioChunk::_internal_set_chunk(const std::string& value) {
  
  chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AudioChunk::set_chunk(std::string&& value) {
  
  chunk_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.AudioChunk.chunk)
}
inline void AudioChunk::set_chunk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.AudioChunk.chunk)
}
inline void AudioChunk::set_chunk(const void* value,
    size_t size) {
  
  chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.AudioChunk.chunk)
}
inline std::string* AudioChunk::_internal_mutable_chunk() {
  
  return chunk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AudioChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AudioChunk.chunk)
  return chunk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AudioChunk::set_allocated_chunk(std::string* chunk) {
  if (chunk != nullptr) {
    
  } else {
    
  }
  chunk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chunk,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AudioChunk.chunk)
}

// -------------------------------------------------------------------

// CustomEvent_Parameter

// string name = 1;
inline void CustomEvent_Parameter::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CustomEvent_Parameter::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.Parameter.name)
  return _internal_name();
}
inline void CustomEvent_Parameter::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.Parameter.name)
}
inline std::string* CustomEvent_Parameter::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.Parameter.name)
  return _internal_mutable_name();
}
inline const std::string& CustomEvent_Parameter::_internal_name() const {
  return name_.Get();
}
inline void CustomEvent_Parameter::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CustomEvent_Parameter::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CustomEvent.Parameter.name)
}
inline void CustomEvent_Parameter::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CustomEvent.Parameter.name)
}
inline void CustomEvent_Parameter::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CustomEvent.Parameter.name)
}
inline std::string* CustomEvent_Parameter::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CustomEvent_Parameter::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.Parameter.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomEvent_Parameter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.Parameter.name)
}

// string value = 2;
inline void CustomEvent_Parameter::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& CustomEvent_Parameter::value() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.Parameter.value)
  return _internal_value();
}
inline void CustomEvent_Parameter::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.Parameter.value)
}
inline std::string* CustomEvent_Parameter::mutable_value() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.Parameter.value)
  return _internal_mutable_value();
}
inline const std::string& CustomEvent_Parameter::_internal_value() const {
  return value_.Get();
}
inline void CustomEvent_Parameter::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CustomEvent_Parameter::set_value(std::string&& value) {
  
  value_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CustomEvent.Parameter.value)
}
inline void CustomEvent_Parameter::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CustomEvent.Parameter.value)
}
inline void CustomEvent_Parameter::set_value(const char* value,
    size_t size) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CustomEvent.Parameter.value)
}
inline std::string* CustomEvent_Parameter::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CustomEvent_Parameter::release_value() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.Parameter.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomEvent_Parameter::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.Parameter.value)
}

// -------------------------------------------------------------------

// CustomEvent

// string name = 1;
inline void CustomEvent::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CustomEvent::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.name)
  return _internal_name();
}
inline void CustomEvent::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.name)
}
inline std::string* CustomEvent::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.name)
  return _internal_mutable_name();
}
inline const std::string& CustomEvent::_internal_name() const {
  return name_.Get();
}
inline void CustomEvent::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CustomEvent::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CustomEvent.name)
}
inline void CustomEvent::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CustomEvent.name)
}
inline void CustomEvent::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CustomEvent.name)
}
inline std::string* CustomEvent::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CustomEvent::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CustomEvent.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CustomEvent::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CustomEvent.name)
}

// .ai.inworld.packets.Playback playback = 2;
inline void CustomEvent::clear_playback() {
  playback_ = 0;
}
inline ::ai::inworld::packets::Playback CustomEvent::_internal_playback() const {
  return static_cast< ::ai::inworld::packets::Playback >(playback_);
}
inline ::ai::inworld::packets::Playback CustomEvent::playback() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.playback)
  return _internal_playback();
}
inline void CustomEvent::_internal_set_playback(::ai::inworld::packets::Playback value) {
  
  playback_ = value;
}
inline void CustomEvent::set_playback(::ai::inworld::packets::Playback value) {
  _internal_set_playback(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CustomEvent.playback)
}

// repeated .ai.inworld.packets.CustomEvent.Parameter parameters = 3;
inline int CustomEvent::_internal_parameters_size() const {
  return parameters_.size();
}
inline int CustomEvent::parameters_size() const {
  return _internal_parameters_size();
}
inline void CustomEvent::clear_parameters() {
  parameters_.Clear();
}
inline ::ai::inworld::packets::CustomEvent_Parameter* CustomEvent::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CustomEvent.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >*
CustomEvent::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CustomEvent.parameters)
  return &parameters_;
}
inline const ::ai::inworld::packets::CustomEvent_Parameter& CustomEvent::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::ai::inworld::packets::CustomEvent_Parameter& CustomEvent::parameters(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CustomEvent.parameters)
  return _internal_parameters(index);
}
inline ::ai::inworld::packets::CustomEvent_Parameter* CustomEvent::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::ai::inworld::packets::CustomEvent_Parameter* CustomEvent::add_parameters() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CustomEvent.parameters)
  return _internal_add_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::CustomEvent_Parameter >&
CustomEvent::parameters() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CustomEvent.parameters)
  return parameters_;
}

// -------------------------------------------------------------------

// CancelResponsesEvent

// string interaction_id = 1;
inline void CancelResponsesEvent::clear_interaction_id() {
  interaction_id_.ClearToEmpty();
}
inline const std::string& CancelResponsesEvent::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _internal_interaction_id();
}
inline void CancelResponsesEvent::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}
inline std::string* CancelResponsesEvent::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& CancelResponsesEvent::_internal_interaction_id() const {
  return interaction_id_.Get();
}
inline void CancelResponsesEvent::_internal_set_interaction_id(const std::string& value) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CancelResponsesEvent::set_interaction_id(std::string&& value) {
  
  interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}
inline void CancelResponsesEvent::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}
inline void CancelResponsesEvent::set_interaction_id(const char* value,
    size_t size) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}
inline std::string* CancelResponsesEvent::_internal_mutable_interaction_id() {
  
  return interaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CancelResponsesEvent::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CancelResponsesEvent.interaction_id)
  return interaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CancelResponsesEvent::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  interaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CancelResponsesEvent.interaction_id)
}

// repeated string utterance_id = 2;
inline int CancelResponsesEvent::_internal_utterance_id_size() const {
  return utterance_id_.size();
}
inline int CancelResponsesEvent::utterance_id_size() const {
  return _internal_utterance_id_size();
}
inline void CancelResponsesEvent::clear_utterance_id() {
  utterance_id_.Clear();
}
inline std::string* CancelResponsesEvent::add_utterance_id() {
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _internal_add_utterance_id();
}
inline const std::string& CancelResponsesEvent::_internal_utterance_id(int index) const {
  return utterance_id_.Get(index);
}
inline const std::string& CancelResponsesEvent::utterance_id(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return _internal_utterance_id(index);
}
inline std::string* CancelResponsesEvent::mutable_utterance_id(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return utterance_id_.Mutable(index);
}
inline void CancelResponsesEvent::set_utterance_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  utterance_id_.Mutable(index)->assign(value);
}
inline void CancelResponsesEvent::set_utterance_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  utterance_id_.Mutable(index)->assign(std::move(value));
}
inline void CancelResponsesEvent::set_utterance_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  utterance_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::set_utterance_id(int index, const char* value, size_t size) {
  utterance_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline std::string* CancelResponsesEvent::_internal_add_utterance_id() {
  return utterance_id_.Add();
}
inline void CancelResponsesEvent::add_utterance_id(const std::string& value) {
  utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(std::string&& value) {
  utterance_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline void CancelResponsesEvent::add_utterance_id(const char* value, size_t size) {
  utterance_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.packets.CancelResponsesEvent.utterance_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CancelResponsesEvent::utterance_id() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return utterance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CancelResponsesEvent::mutable_utterance_id() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CancelResponsesEvent.utterance_id)
  return &utterance_id_;
}

// -------------------------------------------------------------------

// EmotionEvent

// float joy = 1;
inline void EmotionEvent::clear_joy() {
  joy_ = 0;
}
inline float EmotionEvent::_internal_joy() const {
  return joy_;
}
inline float EmotionEvent::joy() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.joy)
  return _internal_joy();
}
inline void EmotionEvent::_internal_set_joy(float value) {
  
  joy_ = value;
}
inline void EmotionEvent::set_joy(float value) {
  _internal_set_joy(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.joy)
}

// float fear = 2;
inline void EmotionEvent::clear_fear() {
  fear_ = 0;
}
inline float EmotionEvent::_internal_fear() const {
  return fear_;
}
inline float EmotionEvent::fear() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.fear)
  return _internal_fear();
}
inline void EmotionEvent::_internal_set_fear(float value) {
  
  fear_ = value;
}
inline void EmotionEvent::set_fear(float value) {
  _internal_set_fear(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.fear)
}

// float trust = 3;
inline void EmotionEvent::clear_trust() {
  trust_ = 0;
}
inline float EmotionEvent::_internal_trust() const {
  return trust_;
}
inline float EmotionEvent::trust() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.trust)
  return _internal_trust();
}
inline void EmotionEvent::_internal_set_trust(float value) {
  
  trust_ = value;
}
inline void EmotionEvent::set_trust(float value) {
  _internal_set_trust(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.trust)
}

// float surprise = 4;
inline void EmotionEvent::clear_surprise() {
  surprise_ = 0;
}
inline float EmotionEvent::_internal_surprise() const {
  return surprise_;
}
inline float EmotionEvent::surprise() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.surprise)
  return _internal_surprise();
}
inline void EmotionEvent::_internal_set_surprise(float value) {
  
  surprise_ = value;
}
inline void EmotionEvent::set_surprise(float value) {
  _internal_set_surprise(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.surprise)
}

// .ai.inworld.packets.EmotionEvent.SpaffCode behavior = 5;
inline void EmotionEvent::clear_behavior() {
  behavior_ = 0;
}
inline ::ai::inworld::packets::EmotionEvent_SpaffCode EmotionEvent::_internal_behavior() const {
  return static_cast< ::ai::inworld::packets::EmotionEvent_SpaffCode >(behavior_);
}
inline ::ai::inworld::packets::EmotionEvent_SpaffCode EmotionEvent::behavior() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.behavior)
  return _internal_behavior();
}
inline void EmotionEvent::_internal_set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value) {
  
  behavior_ = value;
}
inline void EmotionEvent::set_behavior(::ai::inworld::packets::EmotionEvent_SpaffCode value) {
  _internal_set_behavior(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.behavior)
}

// .ai.inworld.packets.EmotionEvent.Strength strength = 6;
inline void EmotionEvent::clear_strength() {
  strength_ = 0;
}
inline ::ai::inworld::packets::EmotionEvent_Strength EmotionEvent::_internal_strength() const {
  return static_cast< ::ai::inworld::packets::EmotionEvent_Strength >(strength_);
}
inline ::ai::inworld::packets::EmotionEvent_Strength EmotionEvent::strength() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.EmotionEvent.strength)
  return _internal_strength();
}
inline void EmotionEvent::_internal_set_strength(::ai::inworld::packets::EmotionEvent_Strength value) {
  
  strength_ = value;
}
inline void EmotionEvent::set_strength(::ai::inworld::packets::EmotionEvent_Strength value) {
  _internal_set_strength(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.EmotionEvent.strength)
}

// -------------------------------------------------------------------

// DataChunk

// bytes chunk = 1;
inline bool DataChunk::_internal_has_chunk() const {
  return data_case() == kChunk;
}
inline void DataChunk::set_has_chunk() {
  _oneof_case_[0] = kChunk;
}
inline void DataChunk::clear_chunk() {
  if (_internal_has_chunk()) {
    data_.chunk_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_data();
  }
}
inline const std::string& DataChunk::chunk() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.chunk)
  return _internal_chunk();
}
inline void DataChunk::set_chunk(const std::string& value) {
  _internal_set_chunk(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.chunk)
}
inline std::string* DataChunk::mutable_chunk() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DataChunk.chunk)
  return _internal_mutable_chunk();
}
inline const std::string& DataChunk::_internal_chunk() const {
  if (_internal_has_chunk()) {
    return data_.chunk_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DataChunk::_internal_set_chunk(const std::string& value) {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  data_.chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DataChunk::set_chunk(std::string&& value) {
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.chunk)
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  data_.chunk_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.DataChunk.chunk)
}
inline void DataChunk::set_chunk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  data_.chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.DataChunk.chunk)
}
inline void DataChunk::set_chunk(const void* value,
                             size_t size) {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  data_.chunk_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.DataChunk.chunk)
}
inline std::string* DataChunk::_internal_mutable_chunk() {
  if (!_internal_has_chunk()) {
    clear_data();
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return data_.chunk_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DataChunk.chunk)
  if (_internal_has_chunk()) {
    clear_has_data();
    return data_.chunk_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void DataChunk::set_allocated_chunk(std::string* chunk) {
  if (has_data()) {
    clear_data();
  }
  if (chunk != nullptr) {
    set_has_chunk();
    data_.chunk_.UnsafeSetDefault(chunk);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(chunk);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.DataChunk.chunk)
}

// int64 duration_ms = 3;
inline bool DataChunk::_internal_has_duration_ms() const {
  return data_case() == kDurationMs;
}
inline void DataChunk::set_has_duration_ms() {
  _oneof_case_[0] = kDurationMs;
}
inline void DataChunk::clear_duration_ms() {
  if (_internal_has_duration_ms()) {
    data_.duration_ms_ = PROTOBUF_LONGLONG(0);
    clear_has_data();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataChunk::_internal_duration_ms() const {
  if (_internal_has_duration_ms()) {
    return data_.duration_ms_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void DataChunk::_internal_set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_duration_ms()) {
    clear_data();
    set_has_duration_ms();
  }
  data_.duration_ms_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataChunk::duration_ms() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.duration_ms)
  return _internal_duration_ms();
}
inline void DataChunk::set_duration_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.duration_ms)
}

// .ai.inworld.packets.DataChunk.DataType type = 2;
inline void DataChunk::clear_type() {
  type_ = 0;
}
inline ::ai::inworld::packets::DataChunk_DataType DataChunk::_internal_type() const {
  return static_cast< ::ai::inworld::packets::DataChunk_DataType >(type_);
}
inline ::ai::inworld::packets::DataChunk_DataType DataChunk::type() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.type)
  return _internal_type();
}
inline void DataChunk::_internal_set_type(::ai::inworld::packets::DataChunk_DataType value) {
  
  type_ = value;
}
inline void DataChunk::set_type(::ai::inworld::packets::DataChunk_DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.type)
}

// repeated .ai.inworld.packets.AdditionalPhonemeInfo additional_phoneme_info = 4;
inline int DataChunk::_internal_additional_phoneme_info_size() const {
  return additional_phoneme_info_.size();
}
inline int DataChunk::additional_phoneme_info_size() const {
  return _internal_additional_phoneme_info_size();
}
inline void DataChunk::clear_additional_phoneme_info() {
  additional_phoneme_info_.Clear();
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::mutable_additional_phoneme_info(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return additional_phoneme_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >*
DataChunk::mutable_additional_phoneme_info() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return &additional_phoneme_info_;
}
inline const ::ai::inworld::packets::AdditionalPhonemeInfo& DataChunk::_internal_additional_phoneme_info(int index) const {
  return additional_phoneme_info_.Get(index);
}
inline const ::ai::inworld::packets::AdditionalPhonemeInfo& DataChunk::additional_phoneme_info(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _internal_additional_phoneme_info(index);
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::_internal_add_additional_phoneme_info() {
  return additional_phoneme_info_.Add();
}
inline ::ai::inworld::packets::AdditionalPhonemeInfo* DataChunk::add_additional_phoneme_info() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return _internal_add_additional_phoneme_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::AdditionalPhonemeInfo >&
DataChunk::additional_phoneme_info() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.DataChunk.additional_phoneme_info)
  return additional_phoneme_info_;
}

// .ai.inworld.packets.DataChunk.AudioFormat audioFormat = 5;
inline void DataChunk::clear_audioformat() {
  audioformat_ = 0;
}
inline ::ai::inworld::packets::DataChunk_AudioFormat DataChunk::_internal_audioformat() const {
  return static_cast< ::ai::inworld::packets::DataChunk_AudioFormat >(audioformat_);
}
inline ::ai::inworld::packets::DataChunk_AudioFormat DataChunk::audioformat() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DataChunk.audioFormat)
  return _internal_audioformat();
}
inline void DataChunk::_internal_set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value) {
  
  audioformat_ = value;
}
inline void DataChunk::set_audioformat(::ai::inworld::packets::DataChunk_AudioFormat value) {
  _internal_set_audioformat(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.DataChunk.audioFormat)
}

inline bool DataChunk::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void DataChunk::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline DataChunk::DataCase DataChunk::data_case() const {
  return DataChunk::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AdditionalPhonemeInfo

// string phoneme = 1;
inline void AdditionalPhonemeInfo::clear_phoneme() {
  phoneme_.ClearToEmpty();
}
inline const std::string& AdditionalPhonemeInfo::phoneme() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _internal_phoneme();
}
inline void AdditionalPhonemeInfo::set_phoneme(const std::string& value) {
  _internal_set_phoneme(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}
inline std::string* AdditionalPhonemeInfo::mutable_phoneme() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return _internal_mutable_phoneme();
}
inline const std::string& AdditionalPhonemeInfo::_internal_phoneme() const {
  return phoneme_.Get();
}
inline void AdditionalPhonemeInfo::_internal_set_phoneme(const std::string& value) {
  
  phoneme_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AdditionalPhonemeInfo::set_phoneme(std::string&& value) {
  
  phoneme_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}
inline void AdditionalPhonemeInfo::set_phoneme(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  phoneme_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}
inline void AdditionalPhonemeInfo::set_phoneme(const char* value,
    size_t size) {
  
  phoneme_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}
inline std::string* AdditionalPhonemeInfo::_internal_mutable_phoneme() {
  
  return phoneme_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AdditionalPhonemeInfo::release_phoneme() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
  return phoneme_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AdditionalPhonemeInfo::set_allocated_phoneme(std::string* phoneme) {
  if (phoneme != nullptr) {
    
  } else {
    
  }
  phoneme_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phoneme,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.phoneme)
}

// .google.protobuf.Duration start_offset = 2;
inline bool AdditionalPhonemeInfo::_internal_has_start_offset() const {
  return this != internal_default_instance() && start_offset_ != nullptr;
}
inline bool AdditionalPhonemeInfo::has_start_offset() const {
  return _internal_has_start_offset();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& AdditionalPhonemeInfo::_internal_start_offset() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = start_offset_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration&>(
      PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& AdditionalPhonemeInfo::start_offset() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  return _internal_start_offset();
}
inline void AdditionalPhonemeInfo::unsafe_arena_set_allocated_start_offset(
    PROTOBUF_NAMESPACE_ID::Duration* start_offset) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_offset_);
  }
  start_offset_ = start_offset;
  if (start_offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
}
inline PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::release_start_offset() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = start_offset_;
  start_offset_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::unsafe_arena_release_start_offset() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = start_offset_;
  start_offset_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::_internal_mutable_start_offset() {
  
  if (start_offset_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    start_offset_ = p;
  }
  return start_offset_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* AdditionalPhonemeInfo::mutable_start_offset() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
  return _internal_mutable_start_offset();
}
inline void AdditionalPhonemeInfo::set_allocated_start_offset(PROTOBUF_NAMESPACE_ID::Duration* start_offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_offset_);
  }
  if (start_offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_offset)->GetArena();
    if (message_arena != submessage_arena) {
      start_offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_offset, submessage_arena);
    }
    
  } else {
    
  }
  start_offset_ = start_offset;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.AdditionalPhonemeInfo.start_offset)
}

// -------------------------------------------------------------------

// ActionEvent

// .ai.inworld.packets.NarratedAction narrated_action = 1;
inline bool ActionEvent::_internal_has_narrated_action() const {
  return action_case() == kNarratedAction;
}
inline bool ActionEvent::has_narrated_action() const {
  return _internal_has_narrated_action();
}
inline void ActionEvent::set_has_narrated_action() {
  _oneof_case_[0] = kNarratedAction;
}
inline void ActionEvent::clear_narrated_action() {
  if (_internal_has_narrated_action()) {
    if (GetArena() == nullptr) {
      delete action_.narrated_action_;
    }
    clear_has_action();
  }
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::release_narrated_action() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ActionEvent.narrated_action)
  if (_internal_has_narrated_action()) {
    clear_has_action();
      ::ai::inworld::packets::NarratedAction* temp = action_.narrated_action_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.narrated_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::NarratedAction& ActionEvent::_internal_narrated_action() const {
  return _internal_has_narrated_action()
      ? *action_.narrated_action_
      : reinterpret_cast< ::ai::inworld::packets::NarratedAction&>(::ai::inworld::packets::_NarratedAction_default_instance_);
}
inline const ::ai::inworld::packets::NarratedAction& ActionEvent::narrated_action() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ActionEvent.narrated_action)
  return _internal_narrated_action();
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::unsafe_arena_release_narrated_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.ActionEvent.narrated_action)
  if (_internal_has_narrated_action()) {
    clear_has_action();
    ::ai::inworld::packets::NarratedAction* temp = action_.narrated_action_;
    action_.narrated_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ActionEvent::unsafe_arena_set_allocated_narrated_action(::ai::inworld::packets::NarratedAction* narrated_action) {
  clear_action();
  if (narrated_action) {
    set_has_narrated_action();
    action_.narrated_action_ = narrated_action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ActionEvent.narrated_action)
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::_internal_mutable_narrated_action() {
  if (!_internal_has_narrated_action()) {
    clear_action();
    set_has_narrated_action();
    action_.narrated_action_ = CreateMaybeMessage< ::ai::inworld::packets::NarratedAction >(GetArena());
  }
  return action_.narrated_action_;
}
inline ::ai::inworld::packets::NarratedAction* ActionEvent::mutable_narrated_action() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ActionEvent.narrated_action)
  return _internal_mutable_narrated_action();
}

// .ai.inworld.packets.Playback playback = 2;
inline void ActionEvent::clear_playback() {
  playback_ = 0;
}
inline ::ai::inworld::packets::Playback ActionEvent::_internal_playback() const {
  return static_cast< ::ai::inworld::packets::Playback >(playback_);
}
inline ::ai::inworld::packets::Playback ActionEvent::playback() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ActionEvent.playback)
  return _internal_playback();
}
inline void ActionEvent::_internal_set_playback(::ai::inworld::packets::Playback value) {
  
  playback_ = value;
}
inline void ActionEvent::set_playback(::ai::inworld::packets::Playback value) {
  _internal_set_playback(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ActionEvent.playback)
}

inline bool ActionEvent::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ActionEvent::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ActionEvent::ActionCase ActionEvent::action_case() const {
  return ActionEvent::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NarratedAction

// string content = 1;
inline void NarratedAction::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& NarratedAction::content() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.NarratedAction.content)
  return _internal_content();
}
inline void NarratedAction::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.NarratedAction.content)
}
inline std::string* NarratedAction::mutable_content() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.NarratedAction.content)
  return _internal_mutable_content();
}
inline const std::string& NarratedAction::_internal_content() const {
  return content_.Get();
}
inline void NarratedAction::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NarratedAction::set_content(std::string&& value) {
  
  content_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.NarratedAction.content)
}
inline void NarratedAction::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.NarratedAction.content)
}
inline void NarratedAction::set_content(const char* value,
    size_t size) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.NarratedAction.content)
}
inline std::string* NarratedAction::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NarratedAction::release_content() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.NarratedAction.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NarratedAction::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.NarratedAction.content)
}

// -------------------------------------------------------------------

// RelationInfo_RelationAttributes

// int32 trust = 1;
inline void RelationInfo_RelationAttributes::clear_trust() {
  trust_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::_internal_trust() const {
  return trust_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::trust() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.trust)
  return _internal_trust();
}
inline void RelationInfo_RelationAttributes::_internal_set_trust(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  trust_ = value;
}
inline void RelationInfo_RelationAttributes::set_trust(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trust(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.trust)
}

// int32 respect = 2;
inline void RelationInfo_RelationAttributes::clear_respect() {
  respect_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::_internal_respect() const {
  return respect_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::respect() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.respect)
  return _internal_respect();
}
inline void RelationInfo_RelationAttributes::_internal_set_respect(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  respect_ = value;
}
inline void RelationInfo_RelationAttributes::set_respect(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_respect(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.respect)
}

// int32 familiar = 3;
inline void RelationInfo_RelationAttributes::clear_familiar() {
  familiar_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::_internal_familiar() const {
  return familiar_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::familiar() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.familiar)
  return _internal_familiar();
}
inline void RelationInfo_RelationAttributes::_internal_set_familiar(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  familiar_ = value;
}
inline void RelationInfo_RelationAttributes::set_familiar(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_familiar(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.familiar)
}

// int32 flirtatious = 4;
inline void RelationInfo_RelationAttributes::clear_flirtatious() {
  flirtatious_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::_internal_flirtatious() const {
  return flirtatious_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::flirtatious() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.flirtatious)
  return _internal_flirtatious();
}
inline void RelationInfo_RelationAttributes::_internal_set_flirtatious(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  flirtatious_ = value;
}
inline void RelationInfo_RelationAttributes::set_flirtatious(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_flirtatious(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.flirtatious)
}

// int32 attraction = 5;
inline void RelationInfo_RelationAttributes::clear_attraction() {
  attraction_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::_internal_attraction() const {
  return attraction_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelationInfo_RelationAttributes::attraction() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.RelationAttributes.attraction)
  return _internal_attraction();
}
inline void RelationInfo_RelationAttributes::_internal_set_attraction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attraction_ = value;
}
inline void RelationInfo_RelationAttributes::set_attraction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attraction(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RelationInfo.RelationAttributes.attraction)
}

// -------------------------------------------------------------------

// RelationInfo

// .ai.inworld.packets.RelationInfo.RelationAttributes relation_state = 1;
inline bool RelationInfo::_internal_has_relation_state() const {
  return this != internal_default_instance() && relation_state_ != nullptr;
}
inline bool RelationInfo::has_relation_state() const {
  return _internal_has_relation_state();
}
inline void RelationInfo::clear_relation_state() {
  if (GetArena() == nullptr && relation_state_ != nullptr) {
    delete relation_state_;
  }
  relation_state_ = nullptr;
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::_internal_relation_state() const {
  const ::ai::inworld::packets::RelationInfo_RelationAttributes* p = relation_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::RelationInfo_RelationAttributes&>(
      ::ai::inworld::packets::_RelationInfo_RelationAttributes_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::relation_state() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.relation_state)
  return _internal_relation_state();
}
inline void RelationInfo::unsafe_arena_set_allocated_relation_state(
    ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(relation_state_);
  }
  relation_state_ = relation_state;
  if (relation_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.RelationInfo.relation_state)
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::release_relation_state() {
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = relation_state_;
  relation_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::unsafe_arena_release_relation_state() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RelationInfo.relation_state)
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = relation_state_;
  relation_state_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::_internal_mutable_relation_state() {
  
  if (relation_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::RelationInfo_RelationAttributes>(GetArena());
    relation_state_ = p;
  }
  return relation_state_;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::mutable_relation_state() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RelationInfo.relation_state)
  return _internal_mutable_relation_state();
}
inline void RelationInfo::set_allocated_relation_state(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete relation_state_;
  }
  if (relation_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(relation_state);
    if (message_arena != submessage_arena) {
      relation_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relation_state, submessage_arena);
    }
    
  } else {
    
  }
  relation_state_ = relation_state;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RelationInfo.relation_state)
}

// .ai.inworld.packets.RelationInfo.RelationAttributes relation_update = 2;
inline bool RelationInfo::_internal_has_relation_update() const {
  return this != internal_default_instance() && relation_update_ != nullptr;
}
inline bool RelationInfo::has_relation_update() const {
  return _internal_has_relation_update();
}
inline void RelationInfo::clear_relation_update() {
  if (GetArena() == nullptr && relation_update_ != nullptr) {
    delete relation_update_;
  }
  relation_update_ = nullptr;
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::_internal_relation_update() const {
  const ::ai::inworld::packets::RelationInfo_RelationAttributes* p = relation_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::RelationInfo_RelationAttributes&>(
      ::ai::inworld::packets::_RelationInfo_RelationAttributes_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo_RelationAttributes& RelationInfo::relation_update() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RelationInfo.relation_update)
  return _internal_relation_update();
}
inline void RelationInfo::unsafe_arena_set_allocated_relation_update(
    ::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(relation_update_);
  }
  relation_update_ = relation_update;
  if (relation_update) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.RelationInfo.relation_update)
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::release_relation_update() {
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = relation_update_;
  relation_update_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::unsafe_arena_release_relation_update() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RelationInfo.relation_update)
  
  ::ai::inworld::packets::RelationInfo_RelationAttributes* temp = relation_update_;
  relation_update_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::_internal_mutable_relation_update() {
  
  if (relation_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::RelationInfo_RelationAttributes>(GetArena());
    relation_update_ = p;
  }
  return relation_update_;
}
inline ::ai::inworld::packets::RelationInfo_RelationAttributes* RelationInfo::mutable_relation_update() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RelationInfo.relation_update)
  return _internal_mutable_relation_update();
}
inline void RelationInfo::set_allocated_relation_update(::ai::inworld::packets::RelationInfo_RelationAttributes* relation_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete relation_update_;
  }
  if (relation_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(relation_update);
    if (message_arena != submessage_arena) {
      relation_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relation_update, submessage_arena);
    }
    
  } else {
    
  }
  relation_update_ = relation_update;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RelationInfo.relation_update)
}

// -------------------------------------------------------------------

// MutationEvent

// .ai.inworld.packets.CancelResponses cancel_responses = 1;
inline bool MutationEvent::_internal_has_cancel_responses() const {
  return mutation_case() == kCancelResponses;
}
inline bool MutationEvent::has_cancel_responses() const {
  return _internal_has_cancel_responses();
}
inline void MutationEvent::set_has_cancel_responses() {
  _oneof_case_[0] = kCancelResponses;
}
inline void MutationEvent::clear_cancel_responses() {
  if (_internal_has_cancel_responses()) {
    if (GetArena() == nullptr) {
      delete mutation_.cancel_responses_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::release_cancel_responses() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.cancel_responses)
  if (_internal_has_cancel_responses()) {
    clear_has_mutation();
      ::ai::inworld::packets::CancelResponses* temp = mutation_.cancel_responses_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.cancel_responses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::CancelResponses& MutationEvent::_internal_cancel_responses() const {
  return _internal_has_cancel_responses()
      ? *mutation_.cancel_responses_
      : reinterpret_cast< ::ai::inworld::packets::CancelResponses&>(::ai::inworld::packets::_CancelResponses_default_instance_);
}
inline const ::ai::inworld::packets::CancelResponses& MutationEvent::cancel_responses() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.cancel_responses)
  return _internal_cancel_responses();
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::unsafe_arena_release_cancel_responses() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.cancel_responses)
  if (_internal_has_cancel_responses()) {
    clear_has_mutation();
    ::ai::inworld::packets::CancelResponses* temp = mutation_.cancel_responses_;
    mutation_.cancel_responses_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_cancel_responses(::ai::inworld::packets::CancelResponses* cancel_responses) {
  clear_mutation();
  if (cancel_responses) {
    set_has_cancel_responses();
    mutation_.cancel_responses_ = cancel_responses;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.cancel_responses)
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::_internal_mutable_cancel_responses() {
  if (!_internal_has_cancel_responses()) {
    clear_mutation();
    set_has_cancel_responses();
    mutation_.cancel_responses_ = CreateMaybeMessage< ::ai::inworld::packets::CancelResponses >(GetArena());
  }
  return mutation_.cancel_responses_;
}
inline ::ai::inworld::packets::CancelResponses* MutationEvent::mutable_cancel_responses() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.cancel_responses)
  return _internal_mutable_cancel_responses();
}

// .ai.inworld.packets.RegenerateResponse regenerate_response = 2;
inline bool MutationEvent::_internal_has_regenerate_response() const {
  return mutation_case() == kRegenerateResponse;
}
inline bool MutationEvent::has_regenerate_response() const {
  return _internal_has_regenerate_response();
}
inline void MutationEvent::set_has_regenerate_response() {
  _oneof_case_[0] = kRegenerateResponse;
}
inline void MutationEvent::clear_regenerate_response() {
  if (_internal_has_regenerate_response()) {
    if (GetArena() == nullptr) {
      delete mutation_.regenerate_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::release_regenerate_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.regenerate_response)
  if (_internal_has_regenerate_response()) {
    clear_has_mutation();
      ::ai::inworld::packets::RegenerateResponse* temp = mutation_.regenerate_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.regenerate_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::RegenerateResponse& MutationEvent::_internal_regenerate_response() const {
  return _internal_has_regenerate_response()
      ? *mutation_.regenerate_response_
      : reinterpret_cast< ::ai::inworld::packets::RegenerateResponse&>(::ai::inworld::packets::_RegenerateResponse_default_instance_);
}
inline const ::ai::inworld::packets::RegenerateResponse& MutationEvent::regenerate_response() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.regenerate_response)
  return _internal_regenerate_response();
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::unsafe_arena_release_regenerate_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.regenerate_response)
  if (_internal_has_regenerate_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::RegenerateResponse* temp = mutation_.regenerate_response_;
    mutation_.regenerate_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_regenerate_response(::ai::inworld::packets::RegenerateResponse* regenerate_response) {
  clear_mutation();
  if (regenerate_response) {
    set_has_regenerate_response();
    mutation_.regenerate_response_ = regenerate_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.regenerate_response)
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::_internal_mutable_regenerate_response() {
  if (!_internal_has_regenerate_response()) {
    clear_mutation();
    set_has_regenerate_response();
    mutation_.regenerate_response_ = CreateMaybeMessage< ::ai::inworld::packets::RegenerateResponse >(GetArena());
  }
  return mutation_.regenerate_response_;
}
inline ::ai::inworld::packets::RegenerateResponse* MutationEvent::mutable_regenerate_response() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.regenerate_response)
  return _internal_mutable_regenerate_response();
}

// .ai.inworld.packets.ApplyResponse apply_response = 3;
inline bool MutationEvent::_internal_has_apply_response() const {
  return mutation_case() == kApplyResponse;
}
inline bool MutationEvent::has_apply_response() const {
  return _internal_has_apply_response();
}
inline void MutationEvent::set_has_apply_response() {
  _oneof_case_[0] = kApplyResponse;
}
inline void MutationEvent::clear_apply_response() {
  if (_internal_has_apply_response()) {
    if (GetArena() == nullptr) {
      delete mutation_.apply_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::release_apply_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.apply_response)
  if (_internal_has_apply_response()) {
    clear_has_mutation();
      ::ai::inworld::packets::ApplyResponse* temp = mutation_.apply_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.apply_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ApplyResponse& MutationEvent::_internal_apply_response() const {
  return _internal_has_apply_response()
      ? *mutation_.apply_response_
      : reinterpret_cast< ::ai::inworld::packets::ApplyResponse&>(::ai::inworld::packets::_ApplyResponse_default_instance_);
}
inline const ::ai::inworld::packets::ApplyResponse& MutationEvent::apply_response() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.apply_response)
  return _internal_apply_response();
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::unsafe_arena_release_apply_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.apply_response)
  if (_internal_has_apply_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::ApplyResponse* temp = mutation_.apply_response_;
    mutation_.apply_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_apply_response(::ai::inworld::packets::ApplyResponse* apply_response) {
  clear_mutation();
  if (apply_response) {
    set_has_apply_response();
    mutation_.apply_response_ = apply_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.apply_response)
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::_internal_mutable_apply_response() {
  if (!_internal_has_apply_response()) {
    clear_mutation();
    set_has_apply_response();
    mutation_.apply_response_ = CreateMaybeMessage< ::ai::inworld::packets::ApplyResponse >(GetArena());
  }
  return mutation_.apply_response_;
}
inline ::ai::inworld::packets::ApplyResponse* MutationEvent::mutable_apply_response() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.apply_response)
  return _internal_mutable_apply_response();
}

// .ai.inworld.packets.LoadScene load_scene = 4;
inline bool MutationEvent::_internal_has_load_scene() const {
  return mutation_case() == kLoadScene;
}
inline bool MutationEvent::has_load_scene() const {
  return _internal_has_load_scene();
}
inline void MutationEvent::set_has_load_scene() {
  _oneof_case_[0] = kLoadScene;
}
inline void MutationEvent::clear_load_scene() {
  if (_internal_has_load_scene()) {
    if (GetArena() == nullptr) {
      delete mutation_.load_scene_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::release_load_scene() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.load_scene)
  if (_internal_has_load_scene()) {
    clear_has_mutation();
      ::ai::inworld::packets::LoadScene* temp = mutation_.load_scene_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.load_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::LoadScene& MutationEvent::_internal_load_scene() const {
  return _internal_has_load_scene()
      ? *mutation_.load_scene_
      : reinterpret_cast< ::ai::inworld::packets::LoadScene&>(::ai::inworld::packets::_LoadScene_default_instance_);
}
inline const ::ai::inworld::packets::LoadScene& MutationEvent::load_scene() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.load_scene)
  return _internal_load_scene();
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::unsafe_arena_release_load_scene() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.load_scene)
  if (_internal_has_load_scene()) {
    clear_has_mutation();
    ::ai::inworld::packets::LoadScene* temp = mutation_.load_scene_;
    mutation_.load_scene_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_load_scene(::ai::inworld::packets::LoadScene* load_scene) {
  clear_mutation();
  if (load_scene) {
    set_has_load_scene();
    mutation_.load_scene_ = load_scene;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.load_scene)
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::_internal_mutable_load_scene() {
  if (!_internal_has_load_scene()) {
    clear_mutation();
    set_has_load_scene();
    mutation_.load_scene_ = CreateMaybeMessage< ::ai::inworld::packets::LoadScene >(GetArena());
  }
  return mutation_.load_scene_;
}
inline ::ai::inworld::packets::LoadScene* MutationEvent::mutable_load_scene() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.load_scene)
  return _internal_mutable_load_scene();
}

// .ai.inworld.packets.ModifyExactResponse modify_exact_response = 5;
inline bool MutationEvent::_internal_has_modify_exact_response() const {
  return mutation_case() == kModifyExactResponse;
}
inline bool MutationEvent::has_modify_exact_response() const {
  return _internal_has_modify_exact_response();
}
inline void MutationEvent::set_has_modify_exact_response() {
  _oneof_case_[0] = kModifyExactResponse;
}
inline void MutationEvent::clear_modify_exact_response() {
  if (_internal_has_modify_exact_response()) {
    if (GetArena() == nullptr) {
      delete mutation_.modify_exact_response_;
    }
    clear_has_mutation();
  }
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::release_modify_exact_response() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.MutationEvent.modify_exact_response)
  if (_internal_has_modify_exact_response()) {
    clear_has_mutation();
      ::ai::inworld::packets::ModifyExactResponse* temp = mutation_.modify_exact_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    mutation_.modify_exact_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::ModifyExactResponse& MutationEvent::_internal_modify_exact_response() const {
  return _internal_has_modify_exact_response()
      ? *mutation_.modify_exact_response_
      : reinterpret_cast< ::ai::inworld::packets::ModifyExactResponse&>(::ai::inworld::packets::_ModifyExactResponse_default_instance_);
}
inline const ::ai::inworld::packets::ModifyExactResponse& MutationEvent::modify_exact_response() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.MutationEvent.modify_exact_response)
  return _internal_modify_exact_response();
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::unsafe_arena_release_modify_exact_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.MutationEvent.modify_exact_response)
  if (_internal_has_modify_exact_response()) {
    clear_has_mutation();
    ::ai::inworld::packets::ModifyExactResponse* temp = mutation_.modify_exact_response_;
    mutation_.modify_exact_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MutationEvent::unsafe_arena_set_allocated_modify_exact_response(::ai::inworld::packets::ModifyExactResponse* modify_exact_response) {
  clear_mutation();
  if (modify_exact_response) {
    set_has_modify_exact_response();
    mutation_.modify_exact_response_ = modify_exact_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.MutationEvent.modify_exact_response)
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::_internal_mutable_modify_exact_response() {
  if (!_internal_has_modify_exact_response()) {
    clear_mutation();
    set_has_modify_exact_response();
    mutation_.modify_exact_response_ = CreateMaybeMessage< ::ai::inworld::packets::ModifyExactResponse >(GetArena());
  }
  return mutation_.modify_exact_response_;
}
inline ::ai::inworld::packets::ModifyExactResponse* MutationEvent::mutable_modify_exact_response() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.MutationEvent.modify_exact_response)
  return _internal_mutable_modify_exact_response();
}

inline bool MutationEvent::has_mutation() const {
  return mutation_case() != MUTATION_NOT_SET;
}
inline void MutationEvent::clear_has_mutation() {
  _oneof_case_[0] = MUTATION_NOT_SET;
}
inline MutationEvent::MutationCase MutationEvent::mutation_case() const {
  return MutationEvent::MutationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CancelResponses

// string interaction_id = 1;
inline void CancelResponses::clear_interaction_id() {
  interaction_id_.ClearToEmpty();
}
inline const std::string& CancelResponses::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponses.interaction_id)
  return _internal_interaction_id();
}
inline void CancelResponses::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.interaction_id)
}
inline std::string* CancelResponses::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponses.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& CancelResponses::_internal_interaction_id() const {
  return interaction_id_.Get();
}
inline void CancelResponses::_internal_set_interaction_id(const std::string& value) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void CancelResponses::set_interaction_id(std::string&& value) {
  
  interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.CancelResponses.interaction_id)
}
inline void CancelResponses::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponses.interaction_id)
}
inline void CancelResponses::set_interaction_id(const char* value,
    size_t size) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponses.interaction_id)
}
inline std::string* CancelResponses::_internal_mutable_interaction_id() {
  
  return interaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* CancelResponses::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.CancelResponses.interaction_id)
  return interaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CancelResponses::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  interaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.CancelResponses.interaction_id)
}

// repeated string utterance_id = 2;
inline int CancelResponses::_internal_utterance_id_size() const {
  return utterance_id_.size();
}
inline int CancelResponses::utterance_id_size() const {
  return _internal_utterance_id_size();
}
inline void CancelResponses::clear_utterance_id() {
  utterance_id_.Clear();
}
inline std::string* CancelResponses::add_utterance_id() {
  // @@protoc_insertion_point(field_add_mutable:ai.inworld.packets.CancelResponses.utterance_id)
  return _internal_add_utterance_id();
}
inline const std::string& CancelResponses::_internal_utterance_id(int index) const {
  return utterance_id_.Get(index);
}
inline const std::string& CancelResponses::utterance_id(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.CancelResponses.utterance_id)
  return _internal_utterance_id(index);
}
inline std::string* CancelResponses::mutable_utterance_id(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.CancelResponses.utterance_id)
  return utterance_id_.Mutable(index);
}
inline void CancelResponses::set_utterance_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.utterance_id)
  utterance_id_.Mutable(index)->assign(value);
}
inline void CancelResponses::set_utterance_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:ai.inworld.packets.CancelResponses.utterance_id)
  utterance_id_.Mutable(index)->assign(std::move(value));
}
inline void CancelResponses::set_utterance_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  utterance_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::set_utterance_id(int index, const char* value, size_t size) {
  utterance_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.CancelResponses.utterance_id)
}
inline std::string* CancelResponses::_internal_add_utterance_id() {
  return utterance_id_.Add();
}
inline void CancelResponses::add_utterance_id(const std::string& value) {
  utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(std::string&& value) {
  utterance_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  utterance_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ai.inworld.packets.CancelResponses.utterance_id)
}
inline void CancelResponses::add_utterance_id(const char* value, size_t size) {
  utterance_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ai.inworld.packets.CancelResponses.utterance_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CancelResponses::utterance_id() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.CancelResponses.utterance_id)
  return utterance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CancelResponses::mutable_utterance_id() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.CancelResponses.utterance_id)
  return &utterance_id_;
}

// -------------------------------------------------------------------

// RegenerateResponse

// string interaction_id = 1;
inline void RegenerateResponse::clear_interaction_id() {
  interaction_id_.ClearToEmpty();
}
inline const std::string& RegenerateResponse::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.RegenerateResponse.interaction_id)
  return _internal_interaction_id();
}
inline void RegenerateResponse::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.RegenerateResponse.interaction_id)
}
inline std::string* RegenerateResponse::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.RegenerateResponse.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& RegenerateResponse::_internal_interaction_id() const {
  return interaction_id_.Get();
}
inline void RegenerateResponse::_internal_set_interaction_id(const std::string& value) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RegenerateResponse::set_interaction_id(std::string&& value) {
  
  interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.RegenerateResponse.interaction_id)
}
inline void RegenerateResponse::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.RegenerateResponse.interaction_id)
}
inline void RegenerateResponse::set_interaction_id(const char* value,
    size_t size) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.RegenerateResponse.interaction_id)
}
inline std::string* RegenerateResponse::_internal_mutable_interaction_id() {
  
  return interaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RegenerateResponse::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.RegenerateResponse.interaction_id)
  return interaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RegenerateResponse::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  interaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.RegenerateResponse.interaction_id)
}

// -------------------------------------------------------------------

// ApplyResponse

// .ai.inworld.packets.PacketId packet_id = 1;
inline bool ApplyResponse::_internal_has_packet_id() const {
  return this != internal_default_instance() && packet_id_ != nullptr;
}
inline bool ApplyResponse::has_packet_id() const {
  return _internal_has_packet_id();
}
inline void ApplyResponse::clear_packet_id() {
  if (GetArena() == nullptr && packet_id_ != nullptr) {
    delete packet_id_;
  }
  packet_id_ = nullptr;
}
inline const ::ai::inworld::packets::PacketId& ApplyResponse::_internal_packet_id() const {
  const ::ai::inworld::packets::PacketId* p = packet_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::ai::inworld::packets::PacketId&>(
      ::ai::inworld::packets::_PacketId_default_instance_);
}
inline const ::ai::inworld::packets::PacketId& ApplyResponse::packet_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ApplyResponse.packet_id)
  return _internal_packet_id();
}
inline void ApplyResponse::unsafe_arena_set_allocated_packet_id(
    ::ai::inworld::packets::PacketId* packet_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet_id_);
  }
  packet_id_ = packet_id;
  if (packet_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.ApplyResponse.packet_id)
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::release_packet_id() {
  
  ::ai::inworld::packets::PacketId* temp = packet_id_;
  packet_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::unsafe_arena_release_packet_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ApplyResponse.packet_id)
  
  ::ai::inworld::packets::PacketId* temp = packet_id_;
  packet_id_ = nullptr;
  return temp;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::_internal_mutable_packet_id() {
  
  if (packet_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::ai::inworld::packets::PacketId>(GetArena());
    packet_id_ = p;
  }
  return packet_id_;
}
inline ::ai::inworld::packets::PacketId* ApplyResponse::mutable_packet_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ApplyResponse.packet_id)
  return _internal_mutable_packet_id();
}
inline void ApplyResponse::set_allocated_packet_id(::ai::inworld::packets::PacketId* packet_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete packet_id_;
  }
  if (packet_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(packet_id);
    if (message_arena != submessage_arena) {
      packet_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_id, submessage_arena);
    }
    
  } else {
    
  }
  packet_id_ = packet_id;
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ApplyResponse.packet_id)
}

// -------------------------------------------------------------------

// LoadScene

// string name = 1;
inline void LoadScene::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& LoadScene::name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadScene.name)
  return _internal_name();
}
inline void LoadScene::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadScene.name)
}
inline std::string* LoadScene::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadScene.name)
  return _internal_mutable_name();
}
inline const std::string& LoadScene::_internal_name() const {
  return name_.Get();
}
inline void LoadScene::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadScene::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadScene.name)
}
inline void LoadScene::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadScene.name)
}
inline void LoadScene::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadScene.name)
}
inline std::string* LoadScene::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadScene::release_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadScene.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadScene::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadScene.name)
}

// -------------------------------------------------------------------

// ModifyExactResponse

// string interaction_id = 1;
inline void ModifyExactResponse::clear_interaction_id() {
  interaction_id_.ClearToEmpty();
}
inline const std::string& ModifyExactResponse::interaction_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return _internal_interaction_id();
}
inline void ModifyExactResponse::set_interaction_id(const std::string& value) {
  _internal_set_interaction_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ModifyExactResponse.interaction_id)
}
inline std::string* ModifyExactResponse::mutable_interaction_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return _internal_mutable_interaction_id();
}
inline const std::string& ModifyExactResponse::_internal_interaction_id() const {
  return interaction_id_.Get();
}
inline void ModifyExactResponse::_internal_set_interaction_id(const std::string& value) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModifyExactResponse::set_interaction_id(std::string&& value) {
  
  interaction_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.ModifyExactResponse.interaction_id)
}
inline void ModifyExactResponse::set_interaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.ModifyExactResponse.interaction_id)
}
inline void ModifyExactResponse::set_interaction_id(const char* value,
    size_t size) {
  
  interaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.ModifyExactResponse.interaction_id)
}
inline std::string* ModifyExactResponse::_internal_mutable_interaction_id() {
  
  return interaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModifyExactResponse::release_interaction_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ModifyExactResponse.interaction_id)
  return interaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModifyExactResponse::set_allocated_interaction_id(std::string* interaction_id) {
  if (interaction_id != nullptr) {
    
  } else {
    
  }
  interaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ModifyExactResponse.interaction_id)
}

// string exact_text = 2;
inline void ModifyExactResponse::clear_exact_text() {
  exact_text_.ClearToEmpty();
}
inline const std::string& ModifyExactResponse::exact_text() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.ModifyExactResponse.exact_text)
  return _internal_exact_text();
}
inline void ModifyExactResponse::set_exact_text(const std::string& value) {
  _internal_set_exact_text(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.ModifyExactResponse.exact_text)
}
inline std::string* ModifyExactResponse::mutable_exact_text() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.ModifyExactResponse.exact_text)
  return _internal_mutable_exact_text();
}
inline const std::string& ModifyExactResponse::_internal_exact_text() const {
  return exact_text_.Get();
}
inline void ModifyExactResponse::_internal_set_exact_text(const std::string& value) {
  
  exact_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ModifyExactResponse::set_exact_text(std::string&& value) {
  
  exact_text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.ModifyExactResponse.exact_text)
}
inline void ModifyExactResponse::set_exact_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  exact_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.ModifyExactResponse.exact_text)
}
inline void ModifyExactResponse::set_exact_text(const char* value,
    size_t size) {
  
  exact_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.ModifyExactResponse.exact_text)
}
inline std::string* ModifyExactResponse::_internal_mutable_exact_text() {
  
  return exact_text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ModifyExactResponse::release_exact_text() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.ModifyExactResponse.exact_text)
  return exact_text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModifyExactResponse::set_allocated_exact_text(std::string* exact_text) {
  if (exact_text != nullptr) {
    
  } else {
    
  }
  exact_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exact_text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.ModifyExactResponse.exact_text)
}

// -------------------------------------------------------------------

// LoadSceneOutputEvent_Agent

// string agent_id = 1;
inline void LoadSceneOutputEvent_Agent::clear_agent_id() {
  agent_id_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::agent_id() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return _internal_agent_id();
}
inline void LoadSceneOutputEvent_Agent::set_agent_id(const std::string& value) {
  _internal_set_agent_id(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_agent_id() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return _internal_mutable_agent_id();
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_agent_id() const {
  return agent_id_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_agent_id(const std::string& value) {
  
  agent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_agent_id(std::string&& value) {
  
  agent_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}
inline void LoadSceneOutputEvent_Agent::set_agent_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  agent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}
inline void LoadSceneOutputEvent_Agent::set_agent_id(const char* value,
    size_t size) {
  
  agent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_agent_id() {
  
  return agent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::release_agent_id() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
  return agent_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_allocated_agent_id(std::string* agent_id) {
  if (agent_id != nullptr) {
    
  } else {
    
  }
  agent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), agent_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.agent_id)
}

// string brain_name = 2;
inline void LoadSceneOutputEvent_Agent::clear_brain_name() {
  brain_name_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::brain_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return _internal_brain_name();
}
inline void LoadSceneOutputEvent_Agent::set_brain_name(const std::string& value) {
  _internal_set_brain_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_brain_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return _internal_mutable_brain_name();
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_brain_name() const {
  return brain_name_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_brain_name(const std::string& value) {
  
  brain_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_brain_name(std::string&& value) {
  
  brain_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}
inline void LoadSceneOutputEvent_Agent::set_brain_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  brain_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}
inline void LoadSceneOutputEvent_Agent::set_brain_name(const char* value,
    size_t size) {
  
  brain_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_brain_name() {
  
  return brain_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::release_brain_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
  return brain_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_allocated_brain_name(std::string* brain_name) {
  if (brain_name != nullptr) {
    
  } else {
    
  }
  brain_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), brain_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.brain_name)
}

// string given_name = 3;
inline void LoadSceneOutputEvent_Agent::clear_given_name() {
  given_name_.ClearToEmpty();
}
inline const std::string& LoadSceneOutputEvent_Agent::given_name() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return _internal_given_name();
}
inline void LoadSceneOutputEvent_Agent::set_given_name(const std::string& value) {
  _internal_set_given_name(value);
  // @@protoc_insertion_point(field_set:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}
inline std::string* LoadSceneOutputEvent_Agent::mutable_given_name() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return _internal_mutable_given_name();
}
inline const std::string& LoadSceneOutputEvent_Agent::_internal_given_name() const {
  return given_name_.Get();
}
inline void LoadSceneOutputEvent_Agent::_internal_set_given_name(const std::string& value) {
  
  given_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_given_name(std::string&& value) {
  
  given_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}
inline void LoadSceneOutputEvent_Agent::set_given_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  given_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}
inline void LoadSceneOutputEvent_Agent::set_given_name(const char* value,
    size_t size) {
  
  given_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}
inline std::string* LoadSceneOutputEvent_Agent::_internal_mutable_given_name() {
  
  return given_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadSceneOutputEvent_Agent::release_given_name() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
  return given_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadSceneOutputEvent_Agent::set_allocated_given_name(std::string* given_name) {
  if (given_name != nullptr) {
    
  } else {
    
  }
  given_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), given_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ai.inworld.packets.LoadSceneOutputEvent.Agent.given_name)
}

// -------------------------------------------------------------------

// LoadSceneOutputEvent

// repeated .ai.inworld.packets.LoadSceneOutputEvent.Agent agents = 1;
inline int LoadSceneOutputEvent::_internal_agents_size() const {
  return agents_.size();
}
inline int LoadSceneOutputEvent::agents_size() const {
  return _internal_agents_size();
}
inline void LoadSceneOutputEvent::clear_agents() {
  agents_.Clear();
}
inline ::ai::inworld::packets::LoadSceneOutputEvent_Agent* LoadSceneOutputEvent::mutable_agents(int index) {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return agents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >*
LoadSceneOutputEvent::mutable_agents() {
  // @@protoc_insertion_point(field_mutable_list:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return &agents_;
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& LoadSceneOutputEvent::_internal_agents(int index) const {
  return agents_.Get(index);
}
inline const ::ai::inworld::packets::LoadSceneOutputEvent_Agent& LoadSceneOutputEvent::agents(int index) const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _internal_agents(index);
}
inline ::ai::inworld::packets::LoadSceneOutputEvent_Agent* LoadSceneOutputEvent::_internal_add_agents() {
  return agents_.Add();
}
inline ::ai::inworld::packets::LoadSceneOutputEvent_Agent* LoadSceneOutputEvent::add_agents() {
  // @@protoc_insertion_point(field_add:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return _internal_add_agents();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ai::inworld::packets::LoadSceneOutputEvent_Agent >&
LoadSceneOutputEvent::agents() const {
  // @@protoc_insertion_point(field_list:ai.inworld.packets.LoadSceneOutputEvent.agents)
  return agents_;
}

// -------------------------------------------------------------------

// DebugInfoEvent

// .ai.inworld.packets.RelationInfo relation = 1;
inline bool DebugInfoEvent::_internal_has_relation() const {
  return info_case() == kRelation;
}
inline bool DebugInfoEvent::has_relation() const {
  return _internal_has_relation();
}
inline void DebugInfoEvent::set_has_relation() {
  _oneof_case_[0] = kRelation;
}
inline void DebugInfoEvent::clear_relation() {
  if (_internal_has_relation()) {
    if (GetArena() == nullptr) {
      delete info_.relation_;
    }
    clear_has_info();
  }
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::release_relation() {
  // @@protoc_insertion_point(field_release:ai.inworld.packets.DebugInfoEvent.relation)
  if (_internal_has_relation()) {
    clear_has_info();
      ::ai::inworld::packets::RelationInfo* temp = info_.relation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    info_.relation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ai::inworld::packets::RelationInfo& DebugInfoEvent::_internal_relation() const {
  return _internal_has_relation()
      ? *info_.relation_
      : reinterpret_cast< ::ai::inworld::packets::RelationInfo&>(::ai::inworld::packets::_RelationInfo_default_instance_);
}
inline const ::ai::inworld::packets::RelationInfo& DebugInfoEvent::relation() const {
  // @@protoc_insertion_point(field_get:ai.inworld.packets.DebugInfoEvent.relation)
  return _internal_relation();
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::unsafe_arena_release_relation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ai.inworld.packets.DebugInfoEvent.relation)
  if (_internal_has_relation()) {
    clear_has_info();
    ::ai::inworld::packets::RelationInfo* temp = info_.relation_;
    info_.relation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebugInfoEvent::unsafe_arena_set_allocated_relation(::ai::inworld::packets::RelationInfo* relation) {
  clear_info();
  if (relation) {
    set_has_relation();
    info_.relation_ = relation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ai.inworld.packets.DebugInfoEvent.relation)
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::_internal_mutable_relation() {
  if (!_internal_has_relation()) {
    clear_info();
    set_has_relation();
    info_.relation_ = CreateMaybeMessage< ::ai::inworld::packets::RelationInfo >(GetArena());
  }
  return info_.relation_;
}
inline ::ai::inworld::packets::RelationInfo* DebugInfoEvent::mutable_relation() {
  // @@protoc_insertion_point(field_mutable:ai.inworld.packets.DebugInfoEvent.relation)
  return _internal_mutable_relation();
}

inline bool DebugInfoEvent::has_info() const {
  return info_case() != INFO_NOT_SET;
}
inline void DebugInfoEvent::clear_has_info() {
  _oneof_case_[0] = INFO_NOT_SET;
}
inline DebugInfoEvent::InfoCase DebugInfoEvent::info_case() const {
  return DebugInfoEvent::InfoCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace packets
}  // namespace inworld
}  // namespace ai

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ai::inworld::packets::Actor_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::Actor_Type>() {
  return ::ai::inworld::packets::Actor_Type_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::TextEvent_SourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::TextEvent_SourceType>() {
  return ::ai::inworld::packets::TextEvent_SourceType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::ControlEvent_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::ControlEvent_Action>() {
  return ::ai::inworld::packets::ControlEvent_Action_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::EmotionEvent_SpaffCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::EmotionEvent_SpaffCode>() {
  return ::ai::inworld::packets::EmotionEvent_SpaffCode_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::EmotionEvent_Strength> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::EmotionEvent_Strength>() {
  return ::ai::inworld::packets::EmotionEvent_Strength_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::DataChunk_DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::DataChunk_DataType>() {
  return ::ai::inworld::packets::DataChunk_DataType_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::DataChunk_AudioFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::DataChunk_AudioFormat>() {
  return ::ai::inworld::packets::DataChunk_AudioFormat_descriptor();
}
template <> struct is_proto_enum< ::ai::inworld::packets::Playback> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ai::inworld::packets::Playback>() {
  return ::ai::inworld::packets::Playback_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_packets_2eproto
